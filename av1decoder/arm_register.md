首先，通用寄存器和neon寄存器是两套

如下是通用寄存器，其实也不是完全“通用”，还有一些特殊寄存器

CPSR 寄存器知识:  用与保存一些当前的程序运行状态：比如cmp指令，执行结果就保存在CPSR中

31 30 29 28 27 26              7 6 5 4    3    2   1     0

N   Z   C   V Q  DNM(RAZ) I F T M4 M3 M2 M1 M0

N（借位标志） ： n=1表示运算结果为负数  0为正数

Z（zero condition flag） ： z=1表示运算的结果为零；z=0表示运算的结果不为零。对于[CMP指令]Z=1表示进行比较的两个数大小相等

C (进位标志)： 在[加法指令]中（包括比较指令CMN），当结果产生了进位,则C=1,表示无符号运算发生溢出(overflow)；其他情况C=0。

在减法指令中（包括比较指令CMP），当运算中发生借位，则C=0，表示无符号运算数发生进位；其他情况下C=1。

对于包含移位操作的非加减运算指令，C中包含最后一次溢出的位的数值

对于其他非加减运算指令，C位的值通常不受影响

V (溢出标志)： 对于加减运算指令，当[操作数]和运算结果为二进制的[补码]表示的[带符号]数时，V=1表示符号位溢出；通常其他指令不影响V位。

-----------

arm32：有9种模式

分为 R0-R15：

- R0-R12 为通用寄存器

- R13 SP 栈指针 ：有8个实际的寄存器，按照CPU模式

    usr和sys模式公用一个，其余7中模式分别有一个

- R14 LR 返回值：

   usr和sys模式公用一个 hyp模式使用的是特殊寄存器ELR_hyp(不属于通用寄存器)

   其余6种模式分别有一个

- P15 PC 程序状态： 就一个



也就是usr模式和sys模式的通用寄存器都是共享的

状态寄存器： arm32 有一个CPSR （Current Program Status Registe）寄存器

​                    7个备用的 SPSR (Saved Program Status Register)

​		usr模式和sys模式 没有对应的 SPSR  其余七种模式都有对应的 SPSR

​            





arm64

通用寄存器：

X0: 也称为零寄存器，用于存储函数的返回值、传递函数参数和临时存储变量。
X1-X7: 用于传递函数参数和临时存储变量。
X8: 也称为程序计数器(PC)，用于存储当前正在执行的指令的地址。当处理器执行一条指令时，PC会自动递增以指向下一条指令。
X9-X15: Caller Saved寄存器，用于存储函数参数、局部变量和临时数据。
X16-X17: 也称为临时寄存器，用于存储临时数据，这些寄存器在函数调用期间不需要保留其值。
X18: 也称为平台相关寄存器，用于存储与特定平台相关的信息，如TLS（线程本地存储）指针。
X19-X28: Callee Saved寄存器，于存储函数参数、局部变量和临时数据。
X29: 也称为帧指针寄存器（Frame Pointer，FP），用于存储当前函数的堆栈帧指针。当函数调用发生时，x29寄存器的值被保存到堆栈中，以便在函数执行期间可以轻松地访问上一级函数的堆栈帧。这样，当函数返回时，可以通过恢复x29寄存器的值来恢复到正确的堆栈帧。
X30: 也称为链接寄存器（Link Register，LR），用于存储函数调用的返回地址。当函数执行完毕时，处理器将使用x30寄存器中存储的返回地址来恢复到调用点。这样，控制流程可以顺利返回到调用函数的位置继续执行。

状态寄存器：arm 64下 没有cpsr寄存器了，将其分为多个寄存器？
寄存器名       查看的标志
NZCV          N, Z, C, V
DAIF          D, A, I, F
CurrentEL     EL
SPSel         SP
PAN           PAN
UAO           UAO
DIT           DIT
SSBS          SSBS
TCO           TCO
ALLINT        ALLINT




四个级别：

EL0、EL1、EL2和EL3是AArch64架构中定义的四个特权级别（Exception Levels），用于支持不同的执行环境和特权级别。它们对应于不同的软件层次和特权级别，包括用户空间、操作系统内核、虚拟化管理器和安全监控器。下面是对这些特权级别的详细介绍：

 EL0是最低特权级别，也称为用户空间。在EL0级别下，执行的是普通应用程序，如用户应用和用户态服务。EL0级别的软件没有直接访问特权指令和受限资源的权限。它运行在操作系统内核之上，并通过系统调用和异常来访问特权功能。
EL1是操作系统内核的特权级别，也称为内核空间。在EL1级别下，操作系统内核运行，并拥有直接访问处理器的所有特权指令和受限资源的权限。EL1级别通常用于操作系统内核的执行，包括处理器的调度、中断处理、内存管理等关键任务。
EL2是虚拟化管理器的特权级别。它允许运行虚拟化管理器（如Hypervisor），用于创建和管理虚拟机。在EL2级别下，虚拟化管理器可以对硬件资源进行虚拟化，并为虚拟机提供虚拟化环境。
EL3是安全监控器的特权级别。它用于实现安全性和可信度，比如使用TrustZone技术实现的安全分区。在EL3级别下，安全监控器可以控制对系统的安全访问，并提供安全隔离和保护，以保护关键数据和系统资源





特殊寄存器 ：

CurrentEL寄存器: 用于存储当前执行指令的异常级别（Exception Level），如 ELR_EL0、ELR_EL1 等。
零寄存器: XZR（扩展为 WZR）寄存器也被称为零寄存器。它始终包含值零（0x0），无法更改。在指令执行期间，可以使用XZR寄存器作为操作数，用于表示零值。零寄存器在条件分支和比较指令中常用于表示零值，以进行条件判断和比较操作。它还可用于将寄存器中的值清零或作为临时存储寄存器。
PC寄存器: PC寄存器存储当前正在执行的指令的地址，它是指示处理器下一条要执行的指令的位置的重要寄存器。当处理器执行一条指令时，PC会自动递增以指向下一条指令。通过修改PC寄存器的值，可以实现跳转和分支，从而改变程序的控制流程。在函数调用过程中，PC寄存器被用于保存下一条要执行的指令的地址，并在函数返回时使用保存的地址来恢复到正确的执行位置。
SP寄存器: 也称为堆栈指针寄存器（Stack Pointer），用于指向当前堆栈的顶部地址。堆栈是一种先进后出（LIFO）的数据结构，用于存储函数调用期间的局部变量、临时数据和返回地址等。在函数调用过程中，SP寄存器会随着数据的入栈和出栈而自动更新。通过递增和递减SP寄存器的值，可以在堆栈上分配和释放内存，以及保存和恢复函数调用的上下文信息。在多线程和多任务环境中，每个线程或任务都有自己的堆栈，而SP寄存器用于指向当前线程或任务的堆栈顶部。
SPSR寄存器: (Saved Program Status Register) 是用于保存先前处理器状态的寄存器。它在异常处理期间用于保存当前状态，以便在异常返回时可以恢复到先前的状态。
ELR寄存器: 也称为异常链接寄存器，用于保存发生异常时的下一条指令的地址，即异常返回地址。不同特权级别的 ELR 对应不同特权级别的寄存器，如 ELR_EL0、ELR_EL1 等。通过这些特权级别相关的寄存器，处理器可以在异常发生时正确切换到相应的特权级别，并保存和恢复相关的上下文信息，确保异常处理和特权级别切换的正确性和安全性。
