![X264](../videocodeciamges/X264.png)

[原图]: ../videocodeciamges/X264.png



# （1）青灰色部分

以x264_为开头的函数，通常是x264对外的API接口，使用青灰色标注，例如x264_encoder_encode()

# （2）红色部分

码率控制分为mb级码控和帧级码控，宏块级码控包括AQ、mbtree，帧级码控包括CQP、CRF、ABR（ABR+VBV=CBR）

# （3）粉色部分

滤波分为几个子模块，环路滤波，半像素差值以及计算质量

# （4）橙色部分

预测分为帧内预测和帧间预测，对16x16以及更小尺寸的宏块进行分析，从而确定最佳的预测模式，如果是帧间预测还需要确定运动矢量

# （5）绿色部分

变换量化模块对预测之后获取的残差进行进一步数据量压缩，同时也会进行反变换反量化来进行帧的重建，重建帧会在后续作为参考分析的依据

# （6）黄色部分

熵编码分为CAVLC和CABAC两个工具，但是通常会使用CABAC，因为其压缩效率较高，也是实际应用中常会使用的熵编码工具





## 1.主干

x264编码主流程当中，主要涉及的内容包括多线程处理，读取配置文件，处理帧的头部信息，处理帧级别的配置信息，进行帧编码之后，释放掉配置文件。应当思考的内容包括：

多线程在工程之上应用很多，尤其是多流的发送和接收，与网络TCP协议结合起来，此外还需要熟悉socket的使用和运用方式
读取配置文件是与外部的接口，里面的配置项，具体涉及到编码器当中的哪个模块，是在哪些地方有影响，影响不同的工具之后，编码的性能有多大的差异，在何种情况下使用何种配置项
帧的头部信息存储的结构是怎样的，每个比特代表的含义是什么，每个变量代表的含义是什么
帧编码的流程是怎样的，使用工具的顺序是怎样的，是如何实现底层的编码的

编码器主函数位于x264.c中，其主要的流程为：

1. 初始化多线程（x264_threading_init），不过在这里函数直接配置为0
2. 初始化默认参数（x264_param_default）
3. 执行编码过程（encode）
4. 清理参数（x264_param_cleanup

```c++
REALIGN_STACK int main( int argc, char **argv )
{
    if( argc == 4 && !strcmp( argv[1], "--autocomplete" ) )
        return x264_cli_autocomplete( argv[2], argv[3] );

    x264_param_t param;
    cli_opt_t opt = {0};
    int ret = 0;
    // ----- 1.初始化多线程 ----- //
    FAIL_IF_ERROR( x264_threading_init(), "unable to initialize threading\n" );

#ifdef _WIN32
    FAIL_IF_ERROR( !get_argv_utf8( &argc, &argv ), "unable to convert command line to UTF-8\n" );

    GetConsoleTitleW( org_console_title, CONSOLE_TITLE_SIZE );
    _setmode( _fileno( stdin ),  _O_BINARY );
    _setmode( _fileno( stdout ), _O_BINARY );
    _setmode( _fileno( stderr ), _O_BINARY );

#endif
	// ----- 2.初始化默认参数 ----- //
    x264_param_default( &param );
    /* Parse command line */
    if( parse( argc, argv, &param, &opt ) < 0 )
        ret = -1;

#ifdef _WIN32
    /* Restore title; it can be changed by input modules */
    SetConsoleTitleW( org_console_title );
#endif

    /* Control-C handler */
    signal( SIGINT, sigint_handler );
    // ----- 3.执行编码过程 ----- //
    if( !ret )
        ret = encode( &param, &opt );
    // ----- 4.释放清理结构体信息 ----- //
    /* clean up handles */
    if( filter.free )
        filter.free( opt.hin );
    else if( opt.hin )
        cli_input.close_file( opt.hin );
    if( opt.hout )
        cli_output.close_file( opt.hout, 0, 0 );
    if( opt.tcfile_out )
        fclose( opt.tcfile_out );
    if( opt.qpfile )
        fclose( opt.qpfile );
    x264_param_cleanup( &param );

#ifdef _WIN32
    SetConsoleTitleW( org_console_title );
    free( argv );
#endif

    return ret;

}
```



### 1.1 初始化多线程（x264_threading_init）

初始化多线程，这里默认配置为0

```c++
#if HAVE_WIN32THREAD || PTW32_STATIC_LIB
X264_API int x264_threading_init( void );
#else
#define x264_threading_init() 0
#endif
```

### 1.2 初始化默认参数（x264_param_default）

### 1.3 编码主函数（encode）

#### 1.3.1 打开编码器（x264_encoder_open）

1. 初始化头部信息
2. 初始化mb信息
3. 初始化frame信息
4. 初始化rdo信息
5. 初始化调用的函数指针
6. 初始化cpu指令集
7. 初始化线程池
8. 检查profile



```c
x264_t *x264_encoder_open( x264_param_t *param, void *api )
{
    x264_t *h;
    char buf[1000], *p;
    int i_slicetype_length;

    CHECKED_MALLOCZERO( h, sizeof(x264_t) );
    
    /* Create a copy of param */
    memcpy( &h->param, param, sizeof(x264_param_t) );
    h->param.opaque = NULL;
    h->param.param_free = NULL;
    
    if( h->param.psz_cqm_file )
        CHECKED_PARAM_STRDUP( h->param.psz_cqm_file, &h->param, h->param.psz_cqm_file );
    if( h->param.psz_dump_yuv )
        CHECKED_PARAM_STRDUP( h->param.psz_dump_yuv, &h->param, h->param.psz_dump_yuv );
    if( h->param.rc.psz_stat_out )
        CHECKED_PARAM_STRDUP( h->param.rc.psz_stat_out, &h->param, h->param.rc.psz_stat_out );
    if( h->param.rc.psz_stat_in )
        CHECKED_PARAM_STRDUP( h->param.rc.psz_stat_in, &h->param, h->param.rc.psz_stat_in );
    if( h->param.rc.psz_zones )
        CHECKED_PARAM_STRDUP( h->param.rc.psz_zones, &h->param, h->param.rc.psz_zones );
    if( h->param.psz_clbin_file )
        CHECKED_PARAM_STRDUP( h->param.psz_clbin_file, &h->param, h->param.psz_clbin_file );
    
    if( param->param_free )
    {
        x264_param_cleanup( param );
        param->param_free( param );
    }
    
    /* Save pointer to bit depth independent interface */
    h->api = api;

#if HAVE_INTEL_DISPATCHER
    x264_intel_dispatcher_override();
#endif

    if( x264_threading_init() )
    {
        x264_log( h, X264_LOG_ERROR, "unable to initialize threading\n" );
        goto fail;
    }
    
    if( validate_parameters( h, 1 ) < 0 )
        goto fail;
    
    if( h->param.psz_cqm_file )
        if( x264_cqm_parse_file( h, h->param.psz_cqm_file ) < 0 )
            goto fail;
    
    x264_reduce_fraction( &h->param.i_fps_num, &h->param.i_fps_den );
    x264_reduce_fraction( &h->param.i_timebase_num, &h->param.i_timebase_den );
    
    /* Init x264_t */
    h->i_frame = -1;
    h->i_frame_num = 0;
    
    if( h->param.i_avcintra_class )
        h->i_idr_pic_id = h->param.i_avcintra_class > 200 ? 4 : 5;
    else
        h->i_idr_pic_id = 0;
    
    if( (uint64_t)h->param.i_timebase_den * 2 > UINT32_MAX )
    {
        x264_log( h, X264_LOG_ERROR, "Effective timebase denominator %u exceeds H.264 maximum\n", h->param.i_timebase_den );
        goto fail;
    }
    
    set_aspect_ratio( h, &h->param, 1 );
    // ----- 1.初始化头部信息 ----- //
    x264_sps_init( h->sps, h->param.i_sps_id, &h->param );
    x264_sps_init_scaling_list( h->sps, &h->param );
    x264_pps_init( h->pps, h->param.i_sps_id, &h->param, h->sps );
    
    x264_validate_levels( h, 1 );
    
    h->chroma_qp_table = i_chroma_qp_table + 12 + h->pps->i_chroma_qp_index_offset;
    
    if( x264_cqm_init( h ) < 0 )
        goto fail;
    // ----- 2.初始化mb信息 ----- //
    h->mb.i_mb_width = h->sps->i_mb_width;
    h->mb.i_mb_height = h->sps->i_mb_height;
    h->mb.i_mb_count = h->mb.i_mb_width * h->mb.i_mb_height;
    
    h->mb.chroma_h_shift = CHROMA_FORMAT == CHROMA_420 || CHROMA_FORMAT == CHROMA_422;
    h->mb.chroma_v_shift = CHROMA_FORMAT == CHROMA_420;
    
    /* Adaptive MBAFF and subme 0 are not supported as we require halving motion
     * vectors during prediction, resulting in hpel mvs.
     * The chosen solution is to make MBAFF non-adaptive in this case. */
    h->mb.b_adaptive_mbaff = PARAM_INTERLACED && h->param.analyse.i_subpel_refine;
    
    // ----- 3.初始化frame信息 ----- //
    /* Init frames. */
    if( h->param.i_bframe_adaptive == X264_B_ADAPT_TRELLIS && !h->param.rc.b_stat_read )
        h->frames.i_delay = X264_MAX(h->param.i_bframe,3)*4;
    else
        h->frames.i_delay = h->param.i_bframe;
    if( h->param.rc.b_mb_tree || h->param.rc.i_vbv_buffer_size )
        h->frames.i_delay = X264_MAX( h->frames.i_delay, h->param.rc.i_lookahead );
    i_slicetype_length = h->frames.i_delay;
    h->frames.i_delay += h->i_thread_frames - 1;
    h->frames.i_delay += h->param.i_sync_lookahead;
    h->frames.i_delay += h->param.b_vfr_input;
    h->frames.i_bframe_delay = h->param.i_bframe ? (h->param.i_bframe_pyramid ? 2 : 1) : 0;
    
    h->frames.i_max_ref0 = h->param.i_frame_reference;
    h->frames.i_max_ref1 = X264_MIN( h->sps->vui.i_num_reorder_frames, h->param.i_frame_reference );
    h->frames.i_max_dpb  = h->sps->vui.i_max_dec_frame_buffering;
    h->frames.b_have_lowres = !h->param.rc.b_stat_read
        && ( h->param.rc.i_rc_method == X264_RC_ABR
          || h->param.rc.i_rc_method == X264_RC_CRF
          || h->param.i_bframe_adaptive
          || h->param.i_scenecut_threshold
          || h->param.rc.b_mb_tree
          || h->param.analyse.i_weighted_pred );
    h->frames.b_have_lowres |= h->param.rc.b_stat_read && h->param.rc.i_vbv_buffer_size > 0;
    h->frames.b_have_sub8x8_esa = !!(h->param.analyse.inter & X264_ANALYSE_PSUB8x8);
    
    h->frames.i_last_idr =
    h->frames.i_last_keyframe = - h->param.i_keyint_max;
    h->frames.i_input    = 0;
    h->frames.i_largest_pts = h->frames.i_second_largest_pts = -1;
    h->frames.i_poc_last_open_gop = -1;
    
    CHECKED_MALLOCZERO( h->cost_table, sizeof(*h->cost_table) );
    CHECKED_MALLOCZERO( h->frames.unused[0], (h->frames.i_delay + 3) * sizeof(x264_frame_t *) );
    /* Allocate room for max refs plus a few extra just in case. */
    CHECKED_MALLOCZERO( h->frames.unused[1], (h->i_thread_frames + X264_REF_MAX + 4) * sizeof(x264_frame_t *) );
    CHECKED_MALLOCZERO( h->frames.current, (h->param.i_sync_lookahead + h->param.i_bframe
                        + h->i_thread_frames + 3) * sizeof(x264_frame_t *) );
    if( h->param.analyse.i_weighted_pred > 0 )
        CHECKED_MALLOCZERO( h->frames.blank_unused, h->i_thread_frames * 4 * sizeof(x264_frame_t *) );
    h->i_ref[0] = h->i_ref[1] = 0;
    h->i_cpb_delay = h->i_coded_fields = h->i_disp_fields = 0;
    h->i_prev_duration = ((uint64_t)h->param.i_fps_den * h->sps->vui.i_time_scale) / ((uint64_t)h->param.i_fps_num * h->sps->vui.i_num_units_in_tick);
    h->i_disp_fields_last_frame = -1;
    // ----- 4.初始化rdo信息 ----- //
    // 预先计算在单一上下文中编码各种比特组合的成本
    x264_rdo_init();
    
    /* init CPU functions */

#if (ARCH_X86 || ARCH_X86_64) && HIGH_BIT_DEPTH
    /* FIXME: Only 8-bit has been optimized for AVX-512 so far. The few AVX-512 functions
     * enabled in high bit-depth are insignificant and just causes potential issues with
     * unnecessary thermal throttling and whatnot, so keep it disabled for now. */
    h->param.cpu &= ~X264_CPU_AVX512;
#endif
	// ----- 5.初始化调用的函数指针 ----- //
	// 初始化预测信息，执行的工作是将函数指针赋值给如h->predict_16x16，方便后续的调用
    x264_predict_16x16_init( h->param.cpu, h->predict_16x16 );
    x264_predict_8x8c_init( h->param.cpu, h->predict_8x8c );
    x264_predict_8x16c_init( h->param.cpu, h->predict_8x16c );
    x264_predict_8x8_init( h->param.cpu, h->predict_8x8, &h->predict_8x8_filter );
    x264_predict_4x4_init( h->param.cpu, h->predict_4x4 );
    x264_pixel_init( h->param.cpu, &h->pixf ); 
	// 初始化dct变换的函数指针
    x264_dct_init( h->param.cpu, &h->dctf );
	// 初始化zigzag搜索的函数指针
    x264_zigzag_init( h->param.cpu, &h->zigzagf_progressive, &h->zigzagf_interlaced );
    memcpy( &h->zigzagf, PARAM_INTERLACED ? &h->zigzagf_interlaced : &h->zigzagf_progressive, sizeof(h->zigzagf) );
    // 初始化运动补偿的函数指针
	x264_mc_init( h->param.cpu, &h->mc, h->param.b_cpu_independent );
	// 初始化量化的函数指针
    x264_quant_init( h, h->param.cpu, &h->quantf );
	// 初始化去块滤波的函数指针
    x264_deblock_init( h->param.cpu, &h->loopf, PARAM_INTERLACED );
    x264_bitstream_init( h->param.cpu, &h->bsf );
	// 初始化CABAC的函数指针
    if( h->param.b_cabac )
        x264_cabac_init( h );
    else
        x264_cavlc_init( h );

    mbcmp_init( h );
    chroma_dsp_init( h );
    
    p = buf + sprintf( buf, "using cpu capabilities:" );
    // ----- 6.初始化cpu指令集 ----- //
    for( int i = 0; x264_cpu_names[i].flags; i++ )
    {
        if( !strcmp(x264_cpu_names[i].name, "SSE")
            && h->param.cpu & (X264_CPU_SSE2) )
            continue;
        if( !strcmp(x264_cpu_names[i].name, "SSE2")
            && h->param.cpu & (X264_CPU_SSE2_IS_FAST|X264_CPU_SSE2_IS_SLOW) )
            continue;
        if( !strcmp(x264_cpu_names[i].name, "SSE3")
            && (h->param.cpu & X264_CPU_SSSE3 || !(h->param.cpu & X264_CPU_CACHELINE_64)) )
            continue;
        if( !strcmp(x264_cpu_names[i].name, "SSE4.1")
            && (h->param.cpu & X264_CPU_SSE42) )
            continue;
        if( !strcmp(x264_cpu_names[i].name, "LZCNT")
            && (h->param.cpu & X264_CPU_BMI1) )
            continue;
        if( !strcmp(x264_cpu_names[i].name, "BMI1")
            && (h->param.cpu & X264_CPU_BMI2) )
            continue;
        if( !strcmp(x264_cpu_names[i].name, "FMA4")
            && (h->param.cpu & X264_CPU_FMA3) )
            continue;
        if( (h->param.cpu & x264_cpu_names[i].flags) == x264_cpu_names[i].flags
            && (!i || x264_cpu_names[i].flags != x264_cpu_names[i-1].flags) )
            p += sprintf( p, " %s", x264_cpu_names[i].name );
    }
    if( !h->param.cpu )
        p += sprintf( p, " none!" );
    x264_log( h, X264_LOG_INFO, "%s\n", buf );
    
    if( x264_analyse_init_costs( h ) )
        goto fail;
    
    /* Must be volatile or else GCC will optimize it out. */
    volatile int temp = 392;
    if( x264_clz( temp ) != 23 )
    {
        x264_log( h, X264_LOG_ERROR, "CLZ test failed: x264 has been miscompiled!\n" );

#if ARCH_X86 || ARCH_X86_64
        x264_log( h, X264_LOG_ERROR, "Are you attempting to run an SSE4a/LZCNT-targeted build on a CPU that\n" );
        x264_log( h, X264_LOG_ERROR, "doesn't support it?\n" );
#endif
        goto fail;
    }

    h->out.i_nal = 0;
    h->out.i_bitstream = x264_clip3f(
        h->param.i_width * h->param.i_height * 4
        * ( h->param.rc.i_rc_method == X264_RC_ABR
            ? pow( 0.95, h->param.rc.i_qp_min )
            : pow( 0.95, h->param.rc.i_qp_constant ) * X264_MAX( 1, h->param.rc.f_ip_factor ) ),
        1000000, INT_MAX/3
    );
    
    h->nal_buffer_size = h->out.i_bitstream * 3/2 + 4 + 64; /* +4 for startcode, +64 for nal_escape assembly padding */
    CHECKED_MALLOC( h->nal_buffer, h->nal_buffer_size );
    
    CHECKED_MALLOC( h->reconfig_h, sizeof(x264_t) );
    // ----- 7.初始化线程池 ----- //
    if( h->param.i_threads > 1 &&
        x264_threadpool_init( &h->threadpool, h->param.i_threads ) )
        goto fail;
    if( h->param.i_lookahead_threads > 1 &&
        x264_threadpool_init( &h->lookaheadpool, h->param.i_lookahead_threads ) )
        goto fail;

#if HAVE_OPENCL
    if( h->param.b_opencl )
    {
        h->opencl.ocl = x264_opencl_load_library();
        if( !h->opencl.ocl )
        {
            x264_log( h, X264_LOG_WARNING, "failed to load OpenCL\n" );
            h->param.b_opencl = 0;
        }
    }
#endif

    h->thread[0] = h;
    for( int i = 1; i < h->param.i_threads + !!h->param.i_sync_lookahead; i++ )
        CHECKED_MALLOC( h->thread[i], sizeof(x264_t) );
    if( h->param.i_lookahead_threads > 1 )
        for( int i = 0; i < h->param.i_lookahead_threads; i++ )
        {
            CHECKED_MALLOC( h->lookahead_thread[i], sizeof(x264_t) );
            *h->lookahead_thread[i] = *h;
        }
    *h->reconfig_h = *h;
    
    for( int i = 0; i < h->param.i_threads; i++ )
    {
        int init_nal_count = h->param.i_slice_count + 3;
        int allocate_threadlocal_data = !h->param.b_sliced_threads || !i;
        if( i > 0 )
            *h->thread[i] = *h;
    
        if( x264_pthread_mutex_init( &h->thread[i]->mutex, NULL ) )
            goto fail;
        if( x264_pthread_cond_init( &h->thread[i]->cv, NULL ) )
            goto fail;
    
        if( allocate_threadlocal_data )
        {
            h->thread[i]->fdec = x264_frame_pop_unused( h, 1 );
            if( !h->thread[i]->fdec )
                goto fail;
        }
        else
            h->thread[i]->fdec = h->thread[0]->fdec;
    
        CHECKED_MALLOC( h->thread[i]->out.p_bitstream, h->out.i_bitstream );
        /* Start each thread with room for init_nal_count NAL units; it'll realloc later if needed. */
        CHECKED_MALLOC( h->thread[i]->out.nal, init_nal_count*sizeof(x264_nal_t) );
        h->thread[i]->out.i_nals_allocated = init_nal_count;
    
        if( allocate_threadlocal_data && x264_macroblock_cache_allocate( h->thread[i] ) < 0 )
            goto fail;
    }

#if HAVE_OPENCL
    if( h->param.b_opencl && x264_opencl_lookahead_init( h ) < 0 )
        h->param.b_opencl = 0;
#endif

    if( x264_lookahead_init( h, i_slicetype_length ) )
        goto fail;
    
    for( int i = 0; i < h->param.i_threads; i++ )
        if( x264_macroblock_thread_allocate( h->thread[i], 0 ) < 0 )
            goto fail;
    
    if( x264_ratecontrol_new( h ) < 0 )
        goto fail;
    
    if( h->param.i_nal_hrd )
    {
        x264_log( h, X264_LOG_DEBUG, "HRD bitrate: %i bits/sec\n", h->sps->vui.hrd.i_bit_rate_unscaled );
        x264_log( h, X264_LOG_DEBUG, "CPB size: %i bits\n", h->sps->vui.hrd.i_cpb_size_unscaled );
    }
    
    if( h->param.psz_dump_yuv )
    {
        /* create or truncate the reconstructed video file */
        FILE *f = x264_fopen( h->param.psz_dump_yuv, "w" );
        if( !f )
        {
            x264_log( h, X264_LOG_ERROR, "dump_yuv: can't write to %s\n", h->param.psz_dump_yuv );
            goto fail;
        }
        else if( !x264_is_regular_file( f ) )
        {
            x264_log( h, X264_LOG_ERROR, "dump_yuv: incompatible with non-regular file %s\n", h->param.psz_dump_yuv );
            fclose( f );
            goto fail;
        }
        fclose( f );
    }
    // ----- 8.检查profile ----- //
    const char *profile = h->sps->i_profile_idc == PROFILE_BASELINE ? "Constrained Baseline" :
                          h->sps->i_profile_idc == PROFILE_MAIN ? "Main" :
                          h->sps->i_profile_idc == PROFILE_HIGH ? "High" :
                          h->sps->i_profile_idc == PROFILE_HIGH10 ?
                              (h->sps->b_constraint_set3 ? "High 10 Intra" : "High 10") :
                          h->sps->i_profile_idc == PROFILE_HIGH422 ?
                              (h->sps->b_constraint_set3 ? "High 4:2:2 Intra" : "High 4:2:2") :
                          h->sps->b_constraint_set3 ? "High 4:4:4 Intra" : "High 4:4:4 Predictive";
    char level[16];
    if( h->sps->i_level_idc == 9 || ( h->sps->i_level_idc == 11 && h->sps->b_constraint_set3 &&
        (h->sps->i_profile_idc == PROFILE_BASELINE || h->sps->i_profile_idc == PROFILE_MAIN) ) )
        strcpy( level, "1b" );
    else
        snprintf( level, sizeof(level), "%d.%d", h->sps->i_level_idc / 10, h->sps->i_level_idc % 10 );
    
    static const char * const subsampling[4] = { "4:0:0", "4:2:0", "4:2:2", "4:4:4" };
    x264_log( h, X264_LOG_INFO, "profile %s, level %s, %s, %d-bit\n",
              profile, level, subsampling[CHROMA_FORMAT], BIT_DEPTH );
    
    return h;

fail:
    x264_free( h );
    return NULL;
}
```

#### 1.3.2 参数拷贝（x264_encoder_parameters）

void x264_encoder_parameters( x264_t *h, x264_param_t *param )
{
    memcpy( param, &h->thread[h->i_thread_phase]->param, sizeof(x264_param_t) );
    param->opaque = NULL;
}

#### 1.3.3 写入头信息（x264_encoder_headers）

int x264_encoder_headers( x264_t *h, x264_nal_t **pp_nal, int *pi_nal )
{
    int frame_size = 0;
    /* init bitstream context */
    h->out.i_nal = 0;
    bs_init( &h->out.bs, h->out.p_bitstream, h->out.i_bitstream );

    /* Write SEI, SPS and PPS. */
    
    /* generate sequence parameters */
    nal_start( h, NAL_SPS, NAL_PRIORITY_HIGHEST );
    x264_sps_write( &h->out.bs, h->sps ); // 写入SPS信息
    if( nal_end( h ) )
        return -1;
    
    /* generate picture parameters */
    nal_start( h, NAL_PPS, NAL_PRIORITY_HIGHEST );
    x264_pps_write( &h->out.bs, h->sps, h->pps ); // 写入PPS信息
    if( nal_end( h ) )
        return -1;
    
    /* identify ourselves */
    nal_start( h, NAL_SEI, NAL_PRIORITY_DISPOSABLE );
    if( x264_sei_version_write( h, &h->out.bs ) )
        return -1;
    if( nal_end( h ) )
        return -1;
    
    frame_size = encoder_encapsulate_nals( h, 0 );
    if( frame_size < 0 )
        return -1;
    
    /* now set output*/
    *pi_nal = h->out.i_nal;
    *pp_nal = &h->out.nal[0];
    h->out.i_nal = 0;
    
    return frame_size;
}

#### 1.3.4 编码流程（encode_frame->x264_encoder_encode）

encode_frame调用了x264_encoder_encode，其主要的工作流程为：

拷贝一帧并移动到buffer中（x264_frame_pop_unused）
拷贝一帧送入队列用于确定帧类型（x264_lookahead_put_frame）
从lookahead获取帧（x264_lookahead_get_frames）
获取要编码的帧（x264_frame_shift）
根据帧的类型初始化数据依赖关系，如I帧，P帧，B帧
构建双向的参考帧列表（reference_build_list）
写入码流文件（x264_sps_write，x264_pps_write等）
开始进行码率控制（x264_ratecontrol_start）
创建帧的头信息（slice_init）
帧编码（slices_write -> slice_write）
处理额外信息且更新编码器状态（encoder_frame_end）
[【x264】编码核心函数x264_encoder_encode简单分析](http://t.csdnimg.cn/WQWB6)

### 1.4 清理参数（x264_param_cleanup）

REALIGN_STACK void x264_param_cleanup( x264_param_t *param )
{
    strdup_buffer *buf = param->opaque;
    if( buf )
    {
        for( int i = 0; i < buf->count; i++ )
            free( buf->ptr[i] );
        free( buf );
        param->opaque = NULL;
    }
}
