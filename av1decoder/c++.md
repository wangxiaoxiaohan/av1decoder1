# 1.讲一讲封装、继承、多态是什么？

# 2.多态的实现原理（实现方式）是什么？以及多态的优点（特点）？

# 3.final标识符的作用是什么？

# 4.虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的

# 5.智能指针的本质是什么，它们的实现原理是什么？

# 6.匿名函数的本质是什么？他的优点是什么？

# 7.右值引用是什么，为什么要引入右值引用？

右值引用是临时变量的引用，‌

**避免不必要的拷贝**‌
传统拷贝构造函数会深拷贝资源（如 `std::vector`），而右值引用允许通过移动语义（Move Semantics）直接“窃取”临时对象的资源（如指针），大幅减少性能开销。

临时变量默认就是右值，若函数参数是引用类型，则不能使用临时变量给它赋值(直接在括号内new)

# 8.左值引用和指针的区别？

底层没有区别 都是指针，引用绑定后不可修改，不可为空

# 9.指针是什么？

# 10.weak_ptr真的不计数？是否有计数方式，在哪分配的空间。

- ‌**weak_ptr不参与"强引用计数"**‌  
  weak_ptr本身不会增加`shared_ptr`的强引用计数（即控制对象生命周期的计数器），因此不会阻止对象的销毁。

- ‌**但存在"弱引用计数"**‌  
  weak_ptr会参与控制块中的‌**弱引用计数**‌，该计数仅用于管理控制块（control block）自身的生命周期，不会影响对象的存活。



- weak_ptr通过‌**弱引用计数**‌管理控制块生命周期
- 计数存储于堆内存的‌**控制块**‌中
- `make_shared`优化了对象与控制块的内存布局，但会绑定两者的生命周期
  
  

# 11.malloc的内存分配的方式，有什么缺点？

需要free，需要初始化，碎片化

## 11.1为什么不全部使用mmap来分配内存？

## 11.2为什么不全部都用brk

# 12.free传入一个指针，它如何确定具体要清理多少空间呢？

1. 在返回给用户的实际指针前方预留隐藏的元数据区
2. 记录关键信息：内存块大小、分配状态、对齐信息等
3. 典型元数据结构示例：  
   ┌────────────┬────────────┐  
   │ 块大小(4B) │ 用户内存区 │  
   └────────────┴────────────┘

# 13.define和const的区别是什么？

# 14.程序运行的步骤是什么

1. Shell解析命令
2. 创建子进程（fork）
3. 加载可执行文件（execve），内核处理（ELF解析，内存分配）
4. 动态链接
5. 设置执行环境
6. 程序执行开始

# 15.锁的底层原理是什么？

# 16.原子操作是什么？

1. ‌**原子性**‌：操作不可中断（要么全执行，要么不执行）
2. ‌**可见性**‌：操作结果立即对所有线程可见
3. ‌**有序性**‌：禁止指令重排序（受内存序参数控制）

# 17.class与struct的区别

| 特性            | struct    | class     |
| ------------- | --------- | --------- |
| 默认访问权限        | public    | private   |
| 默认继承方式        | public继承  | private继承 |
| 模板类型声明        | 可用但非主流    | 主流选择      |
| 类型标识符         | 可声明为final | 同样支持      |
| 模块可见性 (C++26) | 默认外部链接    | 默认模块内链接   |

# 18.内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？

为什么：起始地址必须是4的倍数,8的倍数后者更高的倍数

原因

  性能优化  CPU读取内存以“对齐块”为单位（如4字节/8字节），对齐后单次操作即可完成读取。

    非对齐数据可能跨越两个内存块，需两次读取+拼接，效率下降

cpu缓存命中率更高



struct内存对齐三大规则

### 1. ‌**成员起始地址对齐**‌

每个结构体成员的‌**偏移地址**‌必须是其类型大小（或编译器对齐模数，取较小值）的整数倍。

struct Example1 {
    char a;   // 大小1 → 偏移0
    int b;    // 大小4 → 需从4的倍数开始 → 偏移4
};
// 内存布局：[a][填充3字节][b(4字节)] → 总大小8

### 2. ‌**结构体总大小对齐**‌

结构体的‌**总大小**‌必须是其最大成员对齐值的整数倍（必要时填充末尾）。

struct Example2 {
    short s;  // 大小2 → 偏移0
    char c;   // 大小1 → 偏移2
};            // 总大小需是2的倍数 → 3 → 填充至4
// 内存布局：[s(2字节)][c][填充1字节]

### 3. ‌**嵌套结构体对齐**‌

若结构体嵌套其他结构体成员，该成员的起始地址按‌**内部结构体的最大对齐值**‌对齐。

struct Inner {
    int x;    // 大小4 → 偏移0
    char y;   // 大小1 → 偏移4
};            // Inner总大小8（对齐值4）

struct Outer {
    char a;      // 偏移0
    Inner inner; // 对齐值4 → 需从4开始 → 偏移4
};
// 内存布局：[a][填充3字节][x(4字节)][y][填充3字节] → 总大小12

# 19.进程之间的通信方式有哪些？

### ‌**进程间通信（IPC）方式详解**‌

以下是进程间通信的 ‌**8种核心方式**‌，涵盖原理、特点及适用场景，按 ‌**效率从高到低**‌ 排序：

---

#### ‌**1. 共享内存（Shared Memory）**‌

- ‌**原理**‌：多个进程直接读写同一块物理内存区域。
- ‌**特点**‌：
  - ‌**最快**‌的IPC方式，省去数据复制开销。
  - 需配合 ‌**同步机制**‌（如信号量）避免数据竞争。
- ‌**适用场景**‌：大数据传输（如图像处理、高频交易）。
- ‌**系统调用**‌：`shmget()`、`shmat()`（Linux）。

---

#### ‌**2. 内存映射文件（Memory-Mapped File）**‌

- ‌**原理**‌：将文件映射到进程的虚拟内存空间，多进程共享同一文件映射。
- ‌**特点**‌：
  - 类似共享内存，但依赖文件作为持久化存储。
  - 适用于进程频繁读写文件场景。
- ‌**系统调用**‌：`mmap()`（Linux/Windows）。

---

#### ‌**3. 信号量（Semaphore）**‌

- ‌**原理**‌：通过计数器控制多进程对共享资源的访问权限。
- ‌**特点**‌：
  - 主要用于 ‌**同步**‌，而非直接传输数据。
  - 解决竞态条件（如多进程写同一文件）。
- ‌**系统调用**‌：`sem_init()`、`sem_wait()`（Linux）。

---

#### ‌**4. 消息队列（Message Queue）**‌

- ‌**原理**‌：内核维护的链表结构，进程通过发送/接收消息通信。
- ‌**特点**‌：
  - 支持 ‌**异步通信**‌，消息可指定类型。
  - 数据大小受内核限制，效率低于共享内存。
- ‌**系统调用**‌：`msgget()`、`msgsnd()`（Linux）。

---

#### ‌**5. 命名管道（FIFO）**‌

- ‌**原理**‌：基于文件系统的管道文件，允许无关进程通信。
- ‌**特点**‌：
  - 单向通信，需双向通信时创建两个管道。
  - 适用于长期稳定的进程间通信。
- ‌**系统调用**‌：`mkfifo()`（Linux）。

---

#### ‌**6. 匿名管道（Pipe）**‌

- ‌**原理**‌：内核缓冲区实现单向数据流，仅限父子进程或兄弟进程。
- ‌**特点**‌：
  - 简单轻量，但仅限 ‌**有亲缘关系**‌ 的进程。
  - Shell命令 `|` 的底层实现（如 `ls | grep txt`）。
- ‌**系统调用**‌：`pipe()`（Linux）。

---

#### ‌**7. 信号（Signal）**‌

- ‌**原理**‌：内核向进程发送事件通知（如 `SIGKILL`、`SIGTERM`）。
- ‌**特点**‌：
  - 仅传递 ‌**事件标识**‌，无法携带数据。
  - 适用于进程控制（如终止、挂起）。
- ‌**系统调用**‌：`kill()`、`signal()`（Linux）。

---

#### ‌**8. 套接字（Socket）**‌

- ‌**原理**‌：基于网络协议（TCP/IP或本地Unix域）的跨主机通信。
- ‌**特点**‌：
  - 通用性强，支持 ‌**跨网络通信**‌，但性能较低。
  - 典型应用：浏览器与服务器、分布式系统。
- ‌**系统调用**‌：`socket()`、`bind()`（Linux/Windows）。

# 20.线程之间的通信方式有哪些？

# 21.介绍一下socket中的多路复用，及其他们的优缺点，epoll的水平和边缘触发模式

# 24.类的生命周期

# 25.父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？

# 26.多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？

# 27.描述一下面向过程和面向对象

# 28.C++中左值和右值是什么？++i是左值还是右值，++i和i++哪个效率更高？

# 29.介绍一下vector、list的底层实现原理和优缺点

# 30.静态变量在哪里初始化？在哪一个阶段初始化？（都存放在全局区域）

# 31.如何实现多进程？

# 32.空对象指针为什么能调用函数？

# 33.shared_ptr线程安全吗？

# 34.push_back()左值和右值的区别是什么？

# 35.move底层是怎么实现的？

# 36.完美转发的原理是什么？

# 37.空类中有什么函数？

# 38.explicit用在哪里？有什么作用？

# 39.成员变量初始化的顺序是什么？

# 40.指针占用的大小是多少？

# 41.野指针和内存泄漏是什么？如何避免？

# 42.malloc和new的区别是什么？

# 43.多线程会发生什么问题？线程同步有哪些手段？

# 44.什么是STL？

# 45.对比迭代器和指针的区别

# 46.线程有哪些状态，线程锁有哪些？

# 47.解释说明一下map和unordered_map

# 48.vector中的push_back()和emplace_back()的区别、以及使用场景

# 49.如何实现线程安全，除了加锁还有没有其他的方式？

# 50.vector扩容，resize和reserve的区别

# 51.vector扩容为了避免重复扩容做了哪些机制？

# 52.C++中空类的大小是多少？

# 53.weak_ptr是怎么实现的？

# 54.虚函数的底层原理是什么？

# 55.一个函数f(int a,int b)，其中a和b的地址关系是什么？

# 56.移动构造和拷贝构造的区别是什么？

# 57.lamda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？

# 58.哈希碰撞的处理方法

# 59.unordered_map的扩容过程

# 60.vector如何判断应该扩容？（size和capacity）

# 61.构造函数是否能声明为虚函数？为什么？什么情况下为错误？

# 62.类中static函数是否能声明为虚函数？

# 63.哪些函数不能被声明为虚函数？

# 64.如何保证类的对象只能被开辟在堆上？

将构造函数声明为私有、单例

# 65.讲讲你理解的虚基类

# 66.C++哪些运算符不能被重载？

# 67.动态链接和静态链接的区别，动态链接的原理是什么？

# 68.C++中怎么编译C语言代码？

# 69.未初始化的全局变量和初始化的全局变量放在哪里？

# 70.说一下内联函数及其优缺点

# 71.C++11中的auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？

# 72.map和set的区别和底层实现是什么？map取值的 find，[]，at方法的区别(at有越界检查功能)

# 73.详细说一说fcntl的作用

# 74.C++的面向对象主要体现在那些方面？

# 75.介绍一下extern C关键字，为什么会有这个关键字？

# 76.讲一讲迭代器失效及其解决方法

# 77.编译器是如何实现重载的？

# 78.什么是函数调用约定？

# 79.使用条件变量的时候需要注意什么？

# 80.类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？

# 81.强制类型转换有哪几种类型，分别有什么特点？原理是什么？

Static_cast：用于数据类型的强制转换，强制将一种数据类型转化为另一种数据类型。

Const_cast：用于强制去除类似于const这种不能被修改的常数特性。

Reinterpret_cast：用于改变指针或引用的类型，将指针或引用类型转换成一个足够长的整形，将整形转换为指针或引用。

Dynamic_cast：其他三种都是在编译时完成的，它是在运行时处理的，运行时要进行类型检查。转换class常用

# 82.回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？

# 83.Linux中的信号有哪些？

# 84.什么是尾递归？

# 85.为什么会有栈溢出，为什么栈会设置容量？

# 86.二叉树和平衡二叉树的区别

# 87.平衡二叉树的优缺点

# 88.什么是this指针，为什么存在this指针？

# 89.什么是重载、重写、隐藏？

# 90.静态成员函数可以是虚函数吗？为什么？

# 91.构造函数可以为虚函数吗？为什么？

# 92.make_shared函数的优点，缺点？

# 93.函数调用进行的操作：
