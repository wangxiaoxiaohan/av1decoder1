1.讲一讲封装、继承、多态是什么？

2.多态的实现原理（实现方式）是什么？以及多态的优点（特点）？

3.final标识符的作用是什么？

4.虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的

5.智能指针的本质是什么，它们的实现原理是什么？

6.匿名函数的本质是什么？他的优点是什么？

7.右值引用是什么，为什么要引入右值引用？

8.左值引用和指针的区别？

9.指针是什么？

10.weak_ptr真的不计数？是否有计数方式，在哪分配的空间。

11.malloc的内存分配的方式，有什么缺点？

11.1为什么不全部使用mmap来分配内存？

11.2为什么不全部都用brk

12.传入一个指针，它如何确定具体要清理多少空间呢？

13.define和const的区别是什么？

14.程序运行的步骤是什么

15.锁的底层原理是什么？

16.原子操作是什么？

17.class与struct的区别

18.内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？

19.进程之间的通信方式有哪些？

20.线程之间的通信方式有哪些？

21.介绍一下socket中的多路复用，及其他们的优缺点，epoll的水平和边缘触发模式

24.类的生命周期

25.父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？

26.多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？

27.描述一下面向过程和面向对象

28.C++中左值和右值是什么？++i是左值还是右值，++i和i++哪个效率更高？

29.介绍一下vector、list的底层实现原理和优缺点

30.静态变量在哪里初始化？在哪一个阶段初始化？（都存放在全局区域）

31.如何实现多进程？

32.空对象指针为什么能调用函数？

33.shared_ptr线程安全吗？

34.push_back()左值和右值的区别是什么？

35.move底层是怎么实现的？

36.完美转发的原理是什么？

37.空类中有什么函数？

38.explicit用在哪里？有什么作用？

39.成员变量初始化的顺序是什么？

40.指针占用的大小是多少？

41.野指针和内存泄漏是什么？如何避免？

42.malloc和new的区别是什么？

43.多线程会发生什么问题？线程同步有哪些手段？

44.什么是STL？

45.对比迭代器和指针的区别

46.线程有哪些状态，线程锁有哪些？

47.解释说明一下map和unordered_map

48.vector中的push_back()和emplace_back()的区别、以及使用场景

49.如何实现线程安全，除了加锁还有没有其他的方式？

50.vector扩容，resize和reserve的区别

51.vector扩容为了避免重复扩容做了哪些机制？

52.C++中空类的大小是多少？

53.weak_ptr是怎么实现的？

54.虚函数的底层原理是什么？

55.一个函数f(int a,int b)，其中a和b的地址关系是什么？

56.移动构造和拷贝构造的区别是什么？

57.lamda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？

58.哈希碰撞的处理方法

59.unordered_map的扩容过程

60.vector如何判断应该扩容？（size和capacity）

61.构造函数是否能声明为虚函数？为什么？什么情况下为错误？

62.类中static函数是否能声明为虚函数？

63.哪些函数不能被声明为虚函数？

64.如何保证类的对象只能被开辟在堆上？（将构造函数声明为私有、单例）

65.讲讲你理解的虚基类

66.C++哪些运算符不能被重载？

67.动态链接和静态链接的区别，动态链接的原理是什么？

68.C++中怎么编译C语言代码？

69.未初始化的全局变量和初始化的全局变量放在哪里？

70.说一下内联函数及其优缺点

71.C++11中的auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？

72.map和set的区别和底层实现是什么？map取值的 find，[]，at方法的区别(at有越界检查功能)

73.详细说一说fcntl的作用

74.C++的面向对象主要体现在那些方面？

75.介绍一下extern C关键字，为什么会有这个关键字？

76.讲一讲迭代器失效及其解决方法

77.编译器是如何实现重载的？

78.什么是函数调用约定？

79.使用条件变量的时候需要注意什么？

80.类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？

81.强制类型转换有哪几种类型，分别有什么特点？原理是什么？

Static_cast：用于数据类型的强制转换，强制将一种数据类型转化为另一种数据类型。

Const_cast：用于强制去除类似于const这种不能被修改的常数特性。

Reinterpret_cast：用于改变指针或引用的类型，将指针或引用类型转换成一个足够长的整形，将整形转换为指针或引用。

Dynamic_cast：其他三种都是在编译时完成的，它是在运行时处理的，运行时要进行类型检查。

82.回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？

83.Linux中的信号有哪些？

84.什么是尾递归？

85.为什么会有栈溢出，为什么栈会设置容量？

86.二叉树和平衡二叉树的区别

87.平衡二叉树的优缺点

88.什么是this指针，为什么存在this指针？

89.什么是重载、重写、隐藏？

90.静态成员函数可以是虚函数吗？为什么？

91.构造函数可以为虚函数吗？为什么？

92.make_shared函数的优点，缺点？

93.函数调用进行的操作：

