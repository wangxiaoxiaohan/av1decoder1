# 1.讲一讲封装、继承、多态是什么？

# 2.多态的实现原理（实现方式）是什么？以及多态的优点（特点）？

# 3.final标识符的作用是什么？

# 4.虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的

# 5.智能指针的本质是什么，它们的实现原理是什么？

# 6.匿名函数的本质是什么？他的优点是什么？

# 7.右值引用是什么，为什么要引入右值引用？

右值引用是临时变量的引用，‌

**避免不必要的拷贝**‌
传统拷贝构造函数会深拷贝资源（如 `std::vector`），而右值引用允许通过移动语义（Move Semantics）直接“窃取”临时对象的资源（如指针），大幅减少性能开销。

临时变量默认就是右值，若函数参数是引用类型，则不能使用临时变量给它赋值(直接在括号内new)

# 8.左值引用和指针的区别？

底层没有区别 都是指针，引用绑定后不可修改，不可为空

# 9.指针是什么？

# 10.weak_ptr真的不计数？是否有计数方式，在哪分配的空间。

- ‌**weak_ptr不参与"强引用计数"**‌  
  weak_ptr本身不会增加`shared_ptr`的强引用计数（即控制对象生命周期的计数器），因此不会阻止对象的销毁。

- ‌**但存在"弱引用计数"**‌  
  weak_ptr会参与控制块中的‌**弱引用计数**‌，该计数仅用于管理控制块（control block）自身的生命周期，不会影响对象的存活。

- weak_ptr通过‌**弱引用计数**‌管理控制块生命周期
- 计数存储于堆内存的‌**控制块**‌中
- `make_shared`优化了对象与控制块的内存布局，但会绑定两者的生命周期

# 11.malloc的内存分配的方式，有什么缺点？

需要free，需要初始化，碎片化

## 11.1为什么不全部使用mmap来分配内存？

## 11.2为什么不全部都用brk

# 12.free传入一个指针，它如何确定具体要清理多少空间呢？

1. 在返回给用户的实际指针前方预留隐藏的元数据区
2. 记录关键信息：内存块大小、分配状态、对齐信息等
3. 典型元数据结构示例：  
   ┌────────────┬────────────┐  
   │ 块大小(4B) │ 用户内存区 │  
   └────────────┴────────────┘

# 13.define和const的区别是什么？

# 14.程序运行的步骤是什么

1. Shell解析命令
2. 创建子进程（fork）
3. 加载可执行文件（execve），内核处理（ELF解析，内存分配）
4. 动态链接
5. 设置执行环境
6. 程序执行开始

# 15.锁的底层原理是什么？

# 16.原子操作是什么？

1. ‌**原子性**‌：操作不可中断（要么全执行，要么不执行）
2. ‌**可见性**‌：操作结果立即对所有线程可见
3. ‌**有序性**‌：禁止指令重排序（受内存序参数控制）

# 17.class与struct的区别

| 特性            | struct    | class     |
| ------------- | --------- | --------- |
| 默认访问权限        | public    | private   |
| 默认继承方式        | public继承  | private继承 |
| 模板类型声明        | 可用但非主流    | 主流选择      |
| 类型标识符         | 可声明为final | 同样支持      |
| 模块可见性 (C++26) | 默认外部链接    | 默认模块内链接   |

# 18.内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？

为什么：起始地址必须是4的倍数,8的倍数后者更高的倍数

原因

  性能优化  CPU读取内存以“对齐块”为单位（如4字节/8字节），对齐后单次操作即可完成读取。

    非对齐数据可能跨越两个内存块，需两次读取+拼接，效率下降

cpu缓存命中率更高

struct内存对齐三大规则

### 1. ‌**成员起始地址对齐**‌

每个结构体成员的‌**偏移地址**‌必须是其类型大小（或编译器对齐模数，取较小值）的整数倍。

struct Example1 {
    char a;   // 大小1 → 偏移0
    int b;    // 大小4 → 需从4的倍数开始 → 偏移4
};
// 内存布局：[a][填充3字节][b(4字节)] → 总大小8

### 2. ‌**结构体总大小对齐**‌

结构体的‌**总大小**‌必须是其最大成员对齐值的整数倍（必要时填充末尾）。

struct Example2 {
    short s;  // 大小2 → 偏移0
    char c;   // 大小1 → 偏移2
};            // 总大小需是2的倍数 → 3 → 填充至4
// 内存布局：[s(2字节)][c][填充1字节]

### 3. ‌**嵌套结构体对齐**‌

若结构体嵌套其他结构体成员，该成员的起始地址按‌**内部结构体的最大对齐值**‌对齐。

struct Inner {
    int x;    // 大小4 → 偏移0
    char y;   // 大小1 → 偏移4
};            // Inner总大小8（对齐值4）

struct Outer {
    char a;      // 偏移0
    Inner inner; // 对齐值4 → 需从4开始 → 偏移4
};
// 内存布局：[a][填充3字节][x(4字节)][y][填充3字节] → 总大小12

# 19.进程之间的通信方式有哪些？

### ‌**进程间通信（IPC）方式详解**‌

以下是进程间通信的 ‌**8种核心方式**‌，涵盖原理、特点及适用场景，按 ‌**效率从高到低**‌ 排序：

---

#### ‌**1. 共享内存（Shared Memory）**‌

- ‌**原理**‌：多个进程直接读写同一块物理内存区域。
- ‌**特点**‌：
  - ‌**最快**‌的IPC方式，省去数据复制开销。
  - 需配合 ‌**同步机制**‌（如信号量）避免数据竞争。
- ‌**适用场景**‌：大数据传输（如图像处理、高频交易）。
- ‌**系统调用**‌：`shmget()`、`shmat()`（Linux）。

---

#### ‌**2. 内存映射文件（Memory-Mapped File）**‌

- ‌**原理**‌：将文件映射到进程的虚拟内存空间，多进程共享同一文件映射。
- ‌**特点**‌：
  - 类似共享内存，但依赖文件作为持久化存储。
  - 适用于进程频繁读写文件场景。
- ‌**系统调用**‌：`mmap()`（Linux/Windows）。

---

#### ‌**3. 信号量（Semaphore）**‌

- ‌**原理**‌：通过计数器控制多进程对共享资源的访问权限。
- ‌**特点**‌：
  - 主要用于 ‌**同步**‌，而非直接传输数据。
  - 解决竞态条件（如多进程写同一文件）。
- ‌**系统调用**‌：`sem_init()`、`sem_wait()`（Linux）。

---

#### ‌**4. 消息队列（Message Queue）**‌

- ‌**原理**‌：内核维护的链表结构，进程通过发送/接收消息通信。
- ‌**特点**‌：
  - 支持 ‌**异步通信**‌，消息可指定类型。
  - 数据大小受内核限制，效率低于共享内存。
- ‌**系统调用**‌：`msgget()`、`msgsnd()`（Linux）。

---

#### ‌**5. 命名管道（FIFO）**‌

- ‌**原理**‌：基于文件系统的管道文件，允许无关进程通信。
- ‌**特点**‌：
  - 单向通信，需双向通信时创建两个管道。
  - 适用于长期稳定的进程间通信。
- ‌**系统调用**‌：`mkfifo()`（Linux）。

---

#### ‌**6. 匿名管道（Pipe）**‌

- ‌**原理**‌：内核缓冲区实现单向数据流，仅限父子进程或兄弟进程。
- ‌**特点**‌：
  - 简单轻量，但仅限 ‌**有亲缘关系**‌ 的进程。
  - Shell命令 `|` 的底层实现（如 `ls | grep txt`）。
- ‌**系统调用**‌：`pipe()`（Linux）。

---

#### ‌**7. 信号（Signal）**‌

- ‌**原理**‌：内核向进程发送事件通知（如 `SIGKILL`、`SIGTERM`）。
- ‌**特点**‌：
  - 仅传递 ‌**事件标识**‌，无法携带数据。
  - 适用于进程控制（如终止、挂起）。
- ‌**系统调用**‌：`kill()`、`signal()`（Linux）。

---

#### ‌**8. 套接字（Socket）**‌

- ‌**原理**‌：基于网络协议（TCP/IP或本地Unix域）的跨主机通信。
- ‌**特点**‌：
  - 通用性强，支持 ‌**跨网络通信**‌，但性能较低。
  - 典型应用：浏览器与服务器、分布式系统。
- ‌**系统调用**‌：`socket()`、`bind()`（Linux/Windows）。

# 20.线程之间的通信方式有哪些？

准确来说的是线程间数据同步方式

线程之间通信（更准确说是**同步与协作**）的方式与进程间通信（IPC）有显著不同。由于同一进程内的线程共享内存空间（堆、全局变量等），线程间可以直接通过共享内存交换数据，但需要同步机制来避免竞态条件和数据不一致问题。以下是线程间的主要同步与通信方式：

---

### ​**1. 共享变量（Shared Variables）​**

- ​**特点**：线程可以直接读写进程内的全局变量或堆内存。

- ​**风险**：不加控制会导致**数据竞争**​（Data Race）。

- ​**示例**：
  
  c
  
  ```c
  int counter = 0; // 全局变量
  void* thread_func(void* arg) {
      counter++; // 多个线程同时操作需同步
  }
  ```

- ​**注意**：必须通过锁或其他机制保护共享变量。

---

### ​**2. 互斥锁（Mutex）​**

- ​**用途**：确保同一时间只有一个线程访问共享资源（临界区）。

- ​**操作**：
  
  - `pthread_mutex_init()`：初始化锁。
  - `pthread_mutex_lock()`：加锁（阻塞直到获取锁）。
  - `pthread_mutex_unlock()`：解锁。
  - `pthread_mutex_trylock()`：非阻塞尝试加锁。

- ​**示例**：
  
  c
  
  ```c
  pthread_mutex_t mutex;
  void* thread_func(void* arg) {
      pthread_mutex_lock(&mutex);
      // 访问共享资源
      pthread_mutex_unlock(&mutex);
  }
  ```

- ​**注意**：避免死锁（如多个锁的顺序不一致）。

---

### ​**3. 条件变量（Condition Variable）​**

- ​**用途**：线程间通知机制，用于等待某个条件成立（如资源就绪）。

- ​**操作**：
  
  - `pthread_cond_init()`：初始化条件变量。
  - `pthread_cond_wait()`：释放锁并等待条件（需结合互斥锁）。
  - `pthread_cond_signal()`：唤醒一个等待线程。
  - `pthread_cond_broadcast()`：唤醒所有等待线程。

- ​**示例**​（生产者-消费者模型）：
  
  c
  
  ```c
  pthread_mutex_t mutex;
  pthread_cond_t cond;
  int data_ready = 0;
  
  void* consumer(void* arg) {
      pthread_mutex_lock(&mutex);
      while (!data_ready) {
          pthread_cond_wait(&cond, &mutex); // 自动释放锁并等待
      }
      // 消费数据
      pthread_mutex_unlock(&mutex);
  }
  
  void* producer(void* arg) {
      pthread_mutex_lock(&mutex);
      // 生产数据
      data_ready = 1;
      pthread_cond_signal(&cond); // 通知消费者
      pthread_mutex_unlock(&mutex);
  }
  ```

- ​**注意**：`pthread_cond_wait` 必须在循环中检查条件（避免虚假唤醒）。

---

### ​**4. 信号量（Semaphore）​**

- ​**用途**：控制对共享资源的访问数量（允许多个线程同时访问）。

- ​**操作**：
  
  - `sem_init()`：初始化信号量。
  - `sem_wait()`：信号量减1（若为0则阻塞）。
  - `sem_post()`：信号量加1。

- ​**示例**​（限制同时访问资源的线程数）：
  
  c
  
  ```c
  sem_t sem;
  sem_init(&sem, 0, 3); // 允许3个线程同时访问
  
  void* thread_func(void* arg) {
      sem_wait(&sem);
      // 访问资源
      sem_post(&sem);
  }
  ```

- ​**注意**：信号量可以跨进程（需设置 `pshared` 参数），但线程间通常使用 `0`（仅限进程内）。

---

### ​**5. 读写锁（Read-Write Lock）​**

- ​**用途**：区分读/写操作，允许多个读线程或单个写线程。
- ​**操作**：
  - `pthread_rwlock_init()`：初始化读写锁。
  - `pthread_rwlock_rdlock()`：读锁（共享）。
  - `pthread_rwlock_wrlock()`：写锁（独占）。
  - `pthread_rwlock_unlock()`：解锁。
- ​**适用场景**：读多写少的场景（如缓存系统）。

---

### ​**6. 屏障（Barrier）​**

- ​**用途**：让多个线程在某个点同步等待，直到所有线程都到达后才继续执行。

- ​**操作**：
  
  - `pthread_barrier_init()`：初始化屏障。
  - `pthread_barrier_wait()`：等待所有线程到达。

- ​**示例**​（并行计算的分阶段处理）：
  
  c
  
  ```c
  pthread_barrier_t barrier;
  pthread_barrier_init(&barrier, NULL, 3); // 等待3个线程
  
  void* thread_func(void* arg) {
      // 第一阶段计算
      pthread_barrier_wait(&barrier);
      // 所有线程到达后继续执行第二阶段
  }
  ```

---

### ​**7. 自旋锁（Spinlock）​**

- ​**用途**：通过忙等待（Busy-Waiting）实现轻量级锁，适用于临界区极短的场景。
- ​**操作**：
  - `pthread_spin_init()`：初始化自旋锁。
  - `pthread_spin_lock()`：加锁（循环尝试直到成功）。
  - `pthread_spin_unlock()`：解锁。
- ​**与互斥锁的区别**：
  - 互斥锁在阻塞时会让出 CPU。
  - 自旋锁在阻塞时持续占用 CPU，适合多核且临界区极短的场景。

---

### ​**8. 线程局部存储（Thread-Local Storage, TLS）​**

- ​**用途**：为每个线程提供独立的变量副本，避免共享变量的同步问题。

- ​**操作**：
  
  - `__thread` 关键字（GCC扩展）或 `pthread_key_create()`。

- ​**示例**​（C11标准）：
  
  c
  
  ```c
  _Thread_local int counter; // 每个线程有独立的 counter
  ```

---

### ​**选择同步机制的考虑因素**

1. ​**性能**：自旋锁适合短临界区，互斥锁适合长临界区。
2. ​**协作需求**：条件变量用于复杂等待/通知逻辑。
3. ​**并发度**：信号量控制并发数量，读写锁优化读多写少场景。
4. ​**代码复杂度**：屏障适合分阶段任务，TLS 避免共享状态。

# 21.介绍一下socket中的多路复用，及其他们的优缺点，epoll的水平和边缘触发模式

### 一.概述

- ​**`select`/`poll`**：适用于连接数少或跨平台场景，但性能差。
- ​**`epoll`**：Linux下高并发首选，支持海量连接，需根据业务选择LT或ET模式。
- ​**LT vs ET**：
  - LT模式适合对编程友好性要求高的场景。
  - ET模式适合需要极致性能的场景，但需谨慎处理数据读取和非阻塞IO。

### **二、`epoll`的触发模式**

`epoll` 有两种工作模式，通过 `epoll_event.events` 设置 `EPOLLLT`（默认）或 `EPOLLET` 来指定。

#### 1. ​**水平触发（Level-Triggered, LT）​**

- ​**触发条件**：  
  只要Socket缓冲区有数据可读或可写，`epoll_wait()`就会持续通知。
- ​**行为示例**：  
  假设Socket接收缓冲区有2KB数据：
  - 程序读取1KB后，剩余1KB未读。
  - 下次调用`epoll_wait()`时，仍会通知该Socket可读。
- ​**优点**：
  - 编程简单，无需一次性处理所有数据。
  - 避免因未处理完数据导致事件丢失。
- ​**缺点**：
  - 可能频繁触发事件，影响性能（尤其是高并发时）。

---

#### 2. ​**边缘触发（Edge-Triggered, ET）​**

- ​**触发条件**：  
  仅在Socket状态变化时触发一次（如从无数据变为有数据）。
- ​**行为示例**：  
  同样接收2KB数据：
  - 程序读取1KB后停止。
  - 下次调用`epoll_wait()`时，若没有新数据到达，**不会再次通知**。
- ​**优点**：
  - 减少事件触发次数，提升性能。
  - 适合高并发且需高效处理活跃连接的场景。
- ​**缺点**：
  - 必须一次性处理完所有数据，否则会丢失后续事件。
  - 需使用非阻塞IO（`read`/`write`循环到`EAGAIN`错误），否则可能阻塞其他Socket处理。

# 24.类的生命周期### **一、对象的创建与初始化**

#### 1. ​**构造函数（Constructor）​**

- 对象生命周期的起点是构造函数的调用。
- ​**作用**：初始化成员变量、分配资源（如内存、文件句柄等）。
- ​**分类**：
  - ​**默认构造函数**：无参数，如 `MyClass obj;`。
  - ​**参数化构造函数**：带参数的构造函数，如 `MyClass obj(10);`。
  - ​**拷贝构造函数**：通过已有对象初始化新对象，如 `MyClass obj2(obj1);`。
  - ​**移动构造函数（C++11）​**：转移资源所有权，如 `MyClass obj3(std::move(obj1));`。

#### 2. ​**初始化方式**

- ​**直接初始化**：`MyClass obj(10);`

- ​**拷贝初始化**：`MyClass obj = MyClass(10);`（可能触发拷贝构造函数优化）。

- ​**列表初始化（C++11）​**：`MyClass obj{10};` 或 `MyClass obj = {10};`。

- ​**成员初始化列表**：在构造函数中优先初始化成员变量。
  
  cpp
  
  ```cpp
  class MyClass {
      int a;
      std::string s;
  public:
      MyClass(int x, const std::string& str) : a(x), s(str) {}
  };
  ```

---

### ​**二、对象的存储类型与生命周期**

对象的生命周期取决于其存储类型：

#### 1. ​**自动存储期（栈对象）​**

- ​**声明方式**：函数内的局部变量（非`static`）。

- ​**生命周期**：从定义处开始，到作用域（如函数、代码块）结束时销毁。

- ​**示例**：
  
  cpp
  
  ```cpp
  void func() {
      MyClass obj; // 对象在栈上分配，func()结束时自动调用析构函数。
  }
  ```

#### 2. ​**动态存储期（堆对象）​**

- ​**声明方式**：通过 `new` 创建，`delete` 销毁。

- ​**生命周期**：手动控制，需显式释放内存，否则导致内存泄漏。

- ​**示例**：
  
  cpp
  
  ```cpp
  MyClass* ptr = new MyClass(10); // 对象在堆上分配
  delete ptr; // 显式销毁对象
  ```

#### 3. ​**静态存储期（全局/静态对象）​**

- ​**声明方式**：全局变量、命名空间作用域变量、`static` 局部变量。

- ​**生命周期**：
  
  - ​**全局对象**：程序启动时初始化，程序结束时销毁。
  - ​**静态局部对象**：首次执行到定义处时初始化，程序结束时销毁。

- ​**示例**：
  
  cpp
  
  ```cpp
  MyClass globalObj; // 全局对象
  
  void func() {
      static MyClass staticObj; // 静态局部对象
  }
  ```

#### 4. ​**线程局部存储（C++11）​**

- ​**声明方式**：使用 `thread_local` 关键字。

- ​**生命周期**：与所属线程的生命周期一致。

- ​**示例**：
  
  cpp
  
  ```cpp
  thread_local MyClass threadObj; // 每个线程有独立实例
  ```

---

### ​**三、对象的销毁与析构函数**

#### 1. ​**析构函数（Destructor）​**

- 对象生命周期的终点是析构函数的调用。
- ​**作用**：释放资源（如内存、文件句柄、网络连接等）。
- ​**语法**：`~MyClass() { /* 清理代码 */ }`。
- ​**规则**：
  - 析构函数在对象生命周期结束时自动调用。
  - 若未显式定义，编译器生成默认析构函数（仅释放成员变量，不处理动态资源）。

#### 2. ​**虚析构函数**

- ​**多态基类必须声明虚析构函数**，否则通过基类指针删除派生类对象时，只会调用基类的析构函数，导致派生类资源泄漏。

- ​**示例**：
  
  cpp
  
  ```cpp
  class Base {
  public:
      virtual ~Base() {} // 虚析构函数
  };
  class Derived : public Base {
      int* data;
  public:
      Derived() : data(new int[100]) {}
      ~Derived() { delete[] data; } // 正确释放派生类资源
  };
  
  Base* ptr = new Derived();
  delete ptr; // 调用Derived的析构函数
  ```

---

### ​**四、RAII（资源获取即初始化）​**

- ​**核心思想**：将资源（如内存、文件）的生命周期绑定到对象的生命周期。

- ​**实现方式**：在构造函数中获取资源，在析构函数中释放资源。

- ​**优势**：避免资源泄漏，即使发生异常也能保证资源释放。

- ​**示例**：
  
  cpp
  
  ```cpp
  class FileHandler {
      FILE* file;
  public:
      FileHandler(const char* path) : file(fopen(path, "r")) {}
      ~FileHandler() { if (file) fclose(file); }
  };
  
  void readFile() {
      FileHandler fh("data.txt"); // 文件在析构时自动关闭
  }
  ```

---

### ​**五、拷贝与移动语义**

#### 1. ​**拷贝语义**

- ​**拷贝构造函数**：`MyClass(const MyClass& other)`
- ​**拷贝赋值运算符**：`MyClass& operator=(const MyClass& other)`
- ​**深拷贝与浅拷贝**：需根据资源类型决定是否复制底层资源。

#### 2. ​**移动语义（C++11）​**

- ​**移动构造函数**：`MyClass(MyClass&& other)`
- ​**移动赋值运算符**：`MyClass& operator=(MyClass&& other)`
- ​**用途**：优化临时对象（右值）的资源转移，避免不必要的拷贝。

---

### ​**六、常见问题与注意事项**

1. ​**对象切片（Object Slicing）​**​
   
   - 将派生类对象赋值给基类对象时，派生类部分的数据丢失。
   - ​**解决**：使用基类指针或引用。

2. ​**悬垂指针/引用**​
   
   - 对象销毁后，仍通过指针或引用访问其数据。
   - ​**解决**：使用智能指针（`std::unique_ptr`、`std::shared_ptr`）。

3. ​**异常安全**​
   
   - 构造函数中抛出异常会导致对象未完全构造，但已分配的资源需手动释放。
   - ​**解决**：使用RAII封装资源。

4. ​**静态对象初始化顺序**​
   
   - 不同编译单元的全局静态对象初始化顺序不确定。
   - ​**解决**：使用局部静态对象（C++11后线程安全）。

---

### ​**七、生命周期管理的最佳实践**

1. ​**优先使用自动存储期对象**，避免手动内存管理。
2. ​**使用智能指针**​（如 `std::unique_ptr`、`std::shared_ptr`）管理堆对象。
3. ​**遵循RAII原则**，确保资源安全释放。
4. ​**为多态基类声明虚析构函数**。
5. ​**避免返回局部对象的指针/引用**，防止悬垂引用。
6. ​**使用移动语义优化性能**，减少不必要的拷贝。

# 25.父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？

| ​**函数类型**​ | ​**能否为虚函数**​ | ​**原因与后果**​                                 |
| ---------- | ------------ | ------------------------------------------- |
| 构造函数       | ​**否**​      | 语法禁止，虚表未初始化，构造顺序固定。强行声明会导致编译错误。             |
| 析构函数       | ​**是**​（必须）  | 确保多态对象的正确销毁。若基类析构函数非虚，通过基类指针删除派生类对象会导致资源泄漏。 |

# 26.多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？

# 27.描述一下面向过程和面向对象

### ​**对比总结**

| ​**维度**​    | ​**面向过程**​        | ​**面向对象**​         |
| ----------- | ----------------- | ------------------ |
| ​**核心单元**​  | 函数                | 对象                 |
| ​**设计目标**​  | 流程化解决问题           | 模块化协作解决问题          |
| ​**数据与逻辑**​ | 数据与函数分离           | 数据与方法封装在对象中        |
| ​**代码复用**​  | 通过函数库复用           | 通过继承、组合、多态复用       |
| ​**适用场景**​  | 小型程序、算法实现、性能敏感场景  | 中大型项目、复杂业务系统、GUI开发 |
| ​**扩展性**​   | 修改函数或全局数据可能影响其他部分 | 通过新增类或方法扩展，不影响现有代码 |

---

### ​**如何选择编程范式？**

1. ​**面向过程**：
   
   - 适合逻辑简单、注重效率的任务（如数学计算、脚本工具）。
   - 示例：操作系统内核、嵌入式系统、数值计算库。

2. ​**面向对象**：
   
   - 适合业务复杂、需长期维护的系统（如Web应用、游戏开发）。
   - 示例：电商平台、图形编辑器、企业级框架。

实际开发中，两种范式常结合使用。例如，在面向对象系统中，某些底层模块可能用面向过程实现以提高性能。

# 28.C++中左值和右值是什么？++i是左值还是右值，++i和i++哪个效率更高？

- ​**左值（`++i`）​**：返回递增后的对象本身，因此为左值，可修改、有持久身份，适用于高效修改自身。
- ​**右值（`i++`）​**：返回递增前的副本，为临时值，因此为右值，仅用于需要保留原始值的场景。
- ​**效率**：对自定义类型，优先使用 `++i`；对内置类型，两者无差异

# 29.介绍一下vector、list的底层实现原理和优缺点

| ​**特性**​      | `vector`    | `list`        |
| ------------- | ----------- | ------------- |
| ​**底层结构**​    | 动态数组（连续内存）  | 双向链表（非连续内存）   |
| ​**随机访问**​    | O(1)        | O(n)          |
| ​**尾部操作**​    | 均摊 O(1)     | O(1)          |
| ​**中间插入/删除**​ | O(n)        | O(1)（需先遍历到位置） |
| ​**内存占用**​    | 低（仅需容量指针）   | 高（每个节点含两个指针）  |
| ​**缓存友好性**​   | 高           | 低             |
| ​**迭代器失效**​   | 扩容后所有迭代器失效  | 仅被删除元素的迭代器失效  |
| ​**适用场景**​    | 随机访问、尾部操作为主 | 频繁任意位置插入/删除   |

## **一、`vector`的底层实现与特点**

#### ​**底层实现**：

- ​**动态数组**：元素在内存中**连续存储**，支持随机访问（通过下标直接计算地址）。
- ​**扩容机制**：当元素数量超过当前容量（`capacity`）时，会重新分配一块更大的内存（通常为当前容量的**1.5或2倍**），将原有元素拷贝到新内存，然后释放旧内存。
- ​**内存管理**：通过三个指针实现：
  - `start`：指向首元素。
  - `finish`：指向最后一个元素的下一个位置。
  - `end_of_storage`：指向内存块的末尾。

## 二、`list`的底层实现与特点

#### ​**底层实现**：

- ​**双向链表**：每个元素存储在独立节点中，节点包含：
  - 数据域。
  - `prev`指针：指向前驱节点。
  - `next`指针：指向后继节点。
- ​**内存分配**：每次插入新元素时动态分配节点内存，删除时释放

# 30.静态变量在哪里初始化？在哪一个阶段初始化？

# （都存放在全局区域）

| **静态变量类型**​ | ​**初始化位置**​ | ​**初始化阶段**​          | ​**注意事项**​       |
| ----------- | ----------- | -------------------- | ---------------- |
| 全局静态变量      | 静态存储区       | `main`函数前（静态/动态初始化）  | 避免跨编译单元依赖        |
| 局部静态变量      | 静态存储区       | 首次执行到声明处时            | C++11后线程安全       |
| 类的静态成员变量    | 静态存储区       | `main`函数前（需在类外显式初始化） | 必须类外定义，避免头文件中初始化 |

# 31.如何实现多进程？

# 32.空对象指针为什么能调用函数？

### **一、为什么语法上允许调用？**

1. ​**成员函数的本质**：  
   成员函数在编译时会被转换为普通函数，并隐式添加一个`this`指针参数。例如：
   
   cpp
   
   ```cpp
   class MyClass {
   public:
      void func() { /* ... */ } 
      // 编译器转换为：void func(MyClass* this) { ... }
   };
   ```

2. ​**函数调用机制**：  
   当通过指针调用成员函数时，编译器仅需将指针值作为`this`参数传递，**不会立即解引用指针**。因此，即使指针为`nullptr`，只要函数内部不访问对象数据，代码可能暂时不会崩溃。

3. 空指针调用成员函数为何可能不崩溃
   当通过空指针调用成员函数时，是否崩溃取决于函数内部是否访问了 this 指针指向的成员数据：


如果成员函数内部没有使用任何非静态成员变量，则即使 this 指针为空，函数调用也不会触发解引用空指针的操作：

```cpp
class MyClass {
public:
    void safeFunc() { 
        std::cout << "This function does not use member variables." << std::endl;
    }
};

int main() {
    MyClass* ptr = nullptr;
    ptr->safeFunc();  // 可能不会崩溃
    return 0;
}


```

# 33.shared_ptr线程安全吗？

`shared_ptr` 的引用计数通过原子操作实现，**跨线程的拷贝、赋值和析构是线程安全的**。但对指针指向的数据的访问不是线程安全的

配合shared_pt使用，不会增加引用计数，可以用来解决shared_ptr循环引用的问题，可以通过lock()方法获取shared_ptr.

使用建议：

优先使用unique_ptr，除非确实需要共享所有权
创建智能指针时优先使用make_unique/make_shared而不是直接new
使用weak_ptr来避免循环引用
注意避免悬空指针（比如把原始指针存起来后智能指针释放了资源


# 34.push_back()左值和右值的区别是什么？

# 35.move底层是怎么实现的？

# 36.完美转发的原理是什么？

# 37.空类中有什么函数？

# 38.explicit用在哪里？有什么作用？

# 39.成员变量初始化的顺序是什么？

# 40.指针占用的大小是多少？

# 41.野指针和内存泄漏是什么？如何避免？

# 42.malloc和new的区别是什么？

# 43.多线程会发生什么问题？线程同步有哪些手段？

# 44.什么是STL？

# 45.对比迭代器和指针的区别

# 46.线程有哪些状态，线程锁有哪些？

# 47.解释说明一下map和unordered_map

# 48.vector中的push_back()和emplace_back()的区别、以及使用场景

# 49.如何实现线程安全，除了加锁还有没有其他的方式？

# 50.vector扩容，resize和reserve的区别

# 51.vector扩容为了避免重复扩容做了哪些机制？

# 52.C++中空类的大小是多少？

# 53.weak_ptr是怎么实现的？

# 54.虚函数的底层原理是什么？

# 55.一个函数f(int a,int b)，其中a和b的地址关系是什么？

# 56.移动构造和拷贝构造的区别是什么？

# 57.lamda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？

# 58.哈希碰撞的处理方法

# 59.unordered_map的扩容过程

# 60.vector如何判断应该扩容？（size和capacity）

# 61.构造函数是否能声明为虚函数？为什么？什么情况下为错误？

# 62.类中static函数是否能声明为虚函数？

# 63.哪些函数不能被声明为虚函数？

# 64.如何保证类的对象只能被开辟在堆上？

将构造函数声明为私有、单例

# 65.讲讲你理解的虚基类

# 66.C++哪些运算符不能被重载？

# 67.动态链接和静态链接的区别，动态链接的原理是什么？

# 68.C++中怎么编译C语言代码？

# 69.未初始化的全局变量和初始化的全局变量放在哪里？

# 70.说一下内联函数及其优缺点

# 71.C++11中的auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？

# 72.map和set的区别和底层实现是什么？map取值的 find，[]，at方法的区别(at有越界检查功能)

# 73.详细说一说fcntl的作用

# 74.C++的面向对象主要体现在那些方面？

# 75.介绍一下extern C关键字，为什么会有这个关键字？

# 76.讲一讲迭代器失效及其解决方法

# 77.编译器是如何实现重载的？

# 78.什么是函数调用约定？

# 79.使用条件变量的时候需要注意什么？

# 80.类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？

# 81.强制类型转换有哪几种类型，分别有什么特点？原理是什么？

Static_cast：用于数据类型的强制转换，强制将一种数据类型转化为另一种数据类型。

Const_cast：用于强制去除类似于const这种不能被修改的常数特性。

Reinterpret_cast：用于改变指针或引用的类型，将指针或引用类型转换成一个足够长的整形，将整形转换为指针或引用。

Dynamic_cast：其他三种都是在编译时完成的，它是在运行时处理的，运行时要进行类型检查。转换class常用

# 82.回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？

# 83.Linux中的信号有哪些？

# 84.什么是尾递归？

# 85.为什么会有栈溢出，为什么栈会设置容量？

# 86.二叉树和平衡二叉树的区别

# 87.平衡二叉树的优缺点

# 88.什么是this指针，为什么存在this指针？

# 89.什么是重载、重写、隐藏？

# 90.静态成员函数可以是虚函数吗？为什么？

# 91.构造函数可以为虚函数吗？为什么？

# 92.make_shared函数的优点，缺点？

# 93.函数调用进行的操作：2
