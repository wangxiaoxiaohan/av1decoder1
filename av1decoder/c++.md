# 0.静态绑定和动态绑定

- **静态绑定**​（Static Binding）：  
  在编译阶段确定函数调用或变量访问的关联，基于对象的**静态类型**​（声明时的类型）。例如普通函数调用、非虚成员函数、模板实例化等都属于静态绑定

```cpp
Base obj;
obj.NonVirtualFunc();  // 静态绑定，编译时确定调用 Base::NonVirtualFunc()
```

- ​**动态绑定**​（Dynamic Binding）：  
  在运行阶段根据对象的**动态类型**​（实际指向的类型）确定关联，仅针对虚函数（virtual function）通过基类指针或引用调用时触发

```cpp
Derived d;
Base* ptr = &d;
ptr->VirtualFunc();  // 动态绑定，运行时调用 Derived::VirtualFunc()
```

每个含虚函数的类拥有一个虚函数表（vtable），存储虚函数地址。对象实例头部包含指向该表的指针（vptr）。调用虚函数时，通过vptr找到vtable，再根据偏移量调用具体函数 

| ​**特性**   | ​**静态绑定**        | ​**动态绑定**        |
| --------- | ---------------- | ---------------- |
| ​**绑定时间** | 编译期              | 运行期              |
| ​**依赖信息** | 静态类型（声明类型）       | 动态类型（实际对象类型）     |
| ​**核心机制** | 函数地址直接嵌入代码       | 虚函数表（vtable）间接寻址 |
| ​**性能开销** | 无额外开销            | 虚函数表查询（约多1次指针跳转） |
| ​**典型应用** | 非虚函数、重载、模板、运算符重载 | 多态（基类指针/引用调用虚函数） |

# 1.讲一讲封装、继承、多态是什么？

多态就是去完成某一个行为，**不同的对象执行出来的状态不一样**

    重载指的是同名函数，不同参数

   重写指继承函数覆盖

# 2.多态的实现原理（实现方式）是什么？以及多态的优点（特点）？

### C++ 多态的实现原理（实现方式）

---

#### **1. 核心机制：虚函数（Virtual Function）**

多态的实现依赖于**虚函数**。当一个类中声明虚函数时，编译器会自动为该类生成以下结构：

- **虚函数表（vtable）**：
  - 每个包含虚函数的类会自动生成一个虚函数表，表中存储了该类所有虚函数的地址。
  - 虚函数表由编译器维护，对开发者透明。
- **虚函数表指针（vfptr）**：
  - 每个对象中会额外包含一个指向虚函数表的指针（`vfptr`），该指针指向该对象所属类的虚函数表。
  - 例如，在32位系统中，`vfptr`占4字节；在64位系统中占8字节。

---

#### **2. 动态绑定（Dynamic Binding）**

- **调用过程**：  
  当通过基类指针或引用调用虚函数时，程序会通过对象的`vfptr`找到对应的虚函数表，再根据函数在表中的位置找到实际的函数地址，**在运行时动态绑定到正确的函数**。
- **继承与覆盖**：
  - 子类会继承基类的虚函数表，并根据需要覆盖（重写）虚函数。
  - 子类的虚函数表中，被覆盖的函数地址会被替换为子类实现的地址

# 3.final标识符的作用是什么？

## 1 **. 阻止类被继承（修饰类）**

- **作用**：当用`final`修饰一个类时，该类**不能被其他类继承**，即成为**最终类（Final Class）**。

### **2. 阻止虚函数被重写（修饰虚函数）**

- **作用**：当用`final`修饰一个虚函数时，该函数**不能被派生类重写**，即成为**最终虚函数（Final Virtual Function）**。

## **3. 性能优化：允许编译器进行“去虚拟化”**

- **作用**：当类或虚函数被标记为`final`时，编译器可以**提前解析虚函数调用**（即去虚拟化），从而避免运行时的虚表（vtable）查找开销，提升性能。
- **原因**：
  - 如果虚函数被标记为`final`，编译器知道该函数不会被覆盖，因此可以直接内联（inline）或静态绑定。
  - 如果类被标记为`final`，其所有虚函数均无法被派生类覆盖，编译器可进一步优化。

# 4.虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的

#### **虚函数表（vtable）结构**

- **每个类的虚函数表**：
  - 是一个数组，存储该类所有虚函数的地址。
  - 子类的虚函数表会覆盖父类中被重写的函数地址。
- **虚函数表指针（vfptr）**：
  - 存储在对象的开头（或结尾，具体取决于编译器实现）。
  - 通过 `sizeof(Animal)` 可观察到虚函数带来的额外字节（如 `8` 字节）

# 5.智能指针的本质是什么，它们的实现原理是什么？

- **本质**：智能指针是基于 RAII 的资源管理类模板，通过对象生命周期自动管理动态内存。
- **实现原理**：
  - `unique_ptr` 通过 **独占所有权和移动语义** 实现资源独占。
  - `shared_ptr` 通过 **引用计数和控制块** 实现资源共享。
  - `weak_ptr` 通过 **弱引用** 解决循环引用问题。
- **关键设计**：引用计数、控制块、原子操作、移动语义、RAII 原则。

通过这些机制，智能指针显著提升了 C++ 代码的安全性、可维护性和资源管理效率。

# 6.匿名函数的本质是什么？他的优点是什么？

- **本质**：Lambda 是通过编译器生成的匿名类实现的函数对象，结合捕获列表实现闭包特性。
- **核心优点**：
  - 简化代码，提升可读性。
  - 灵活捕获外部变量，避免全局变量。
  - 与 STL 算法无缝结合，增强功能性。
  - 自动资源管理，减少内存问题。

# 7.右值引用是什么，为什么要引入右值引用？

右值引用是临时变量的引用，‌

**避免不必要的拷贝**‌
传统拷贝构造函数会深拷贝资源（如 `std::vector`），而右值引用允许通过移动语义（Move Semantics）直接“窃取”临时对象的资源（如指针），大幅减少性能开销。

临时变量默认就是右值，若函数参数是引用类型，则不能使用临时变量给它赋值(直接在括号内new)

# 8.左值引用和指针的区别？

底层没有区别 都是指针，引用绑定后不可修改，不可为空

# 9.指针是什么？

# 10.weak_ptr真的不计数？是否有计数方式，在哪分配的空间。

- ‌**weak_ptr不参与"强引用计数"**‌  
  weak_ptr本身不会增加`shared_ptr`的强引用计数（即控制对象生命周期的计数器），因此不会阻止对象的销毁。

- ‌**但存在"弱引用计数"**‌  
  weak_ptr会参与控制块中的‌**弱引用计数**‌，该计数仅用于管理控制块（control block）自身的生命周期，不会影响对象的存活。

- weak_ptr通过‌**弱引用计数**‌管理控制块生命周期

- 计数存储于堆内存的‌**控制块**‌中

- `make_shared`优化了对象与控制块的内存布局，但会绑定两者的生命周期

# 11.malloc的内存分配的方式，有什么缺点？

需要free，需要初始化，碎片化

## 11.1为什么不全部使用mmap来分配内存？

## 11.2为什么不全部都用brk

# 12.free传入一个指针，它如何确定具体要清理多少空间呢？

1. 在返回给用户的实际指针前方预留隐藏的元数据区
2. 记录关键信息：内存块大小、分配状态、对齐信息等
3. 典型元数据结构示例：  
   ┌────────────┬────────────┐  
   │ 块大小(4B) │ 用户内存区 │  
   └────────────┴────────────┘

# 13.define和const的区别是什么？

# 14.程序运行的步骤是什么

1. Shell解析命令
2. 创建子进程（fork）
3. 加载可执行文件（execve），内核处理（ELF解析，内存分配）
4. 动态链接
5. 设置执行环境
6. 程序执行开始

# 15.锁的底层原理是什么？

# 16.原子操作是什么？

1. ‌**原子性**‌：操作不可中断（要么全执行，要么不执行）
2. ‌**可见性**‌：操作结果立即对所有线程可见
3. ‌**有序性**‌：禁止指令重排序（受内存序参数控制）

# 17.class与struct的区别

| 特性            | struct    | class     |
| ------------- | --------- | --------- |
| 默认访问权限        | public    | private   |
| 默认继承方式        | public继承  | private继承 |
| 模板类型声明        | 可用但非主流    | 主流选择      |
| 类型标识符         | 可声明为final | 同样支持      |
| 模块可见性 (C++26) | 默认外部链接    | 默认模块内链接   |

# 18.内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？

为什么：起始地址必须是4的倍数,8的倍数后者更高的倍数

原因

  性能优化  CPU读取内存以“对齐块”为单位（如4字节/8字节），对齐后单次操作即可完成读取。

    非对齐数据可能跨越两个内存块，需两次读取+拼接，效率下降

cpu缓存命中率更高

struct内存对齐三大规则

### 1. ‌**成员起始地址对齐**‌

每个结构体成员的‌**偏移地址**‌必须是其类型大小（或编译器对齐模数，取较小值）的整数倍。

struct Example1 {
    char a;   // 大小1 → 偏移0
    int b;    // 大小4 → 需从4的倍数开始 → 偏移4
};
// 内存布局：[a][填充3字节][b(4字节)] → 总大小8

### 2. ‌**结构体总大小对齐**‌

结构体的‌**总大小**‌必须是其最大成员对齐值的整数倍（必要时填充末尾）。

struct Example2 {
    short s;  // 大小2 → 偏移0
    char c;   // 大小1 → 偏移2
};            // 总大小需是2的倍数 → 3 → 填充至4
// 内存布局：[s(2字节)][c][填充1字节]

### 3. ‌**嵌套结构体对齐**‌

若结构体嵌套其他结构体成员，该成员的起始地址按‌**内部结构体的最大对齐值**‌对齐。

struct Inner {
    int x;    // 大小4 → 偏移0
    char y;   // 大小1 → 偏移4
};            // Inner总大小8（对齐值4）

struct Outer {
    char a;      // 偏移0
    Inner inner; // 对齐值4 → 需从4开始 → 偏移4
};
// 内存布局：[a][填充3字节][x(4字节)][y][填充3字节] → 总大小12

# 19.进程之间的通信方式有哪些？

### ‌**进程间通信（IPC）方式详解**‌

以下是进程间通信的 ‌**8种核心方式**‌，涵盖原理、特点及适用场景，按 ‌**效率从高到低**‌ 排序：

---

#### ‌**1. 共享内存（Shared Memory）**‌

- ‌**原理**‌：多个进程直接读写同一块物理内存区域。
- ‌**特点**‌：
  - ‌**最快**‌的IPC方式，省去数据复制开销。
  - 需配合 ‌**同步机制**‌（如信号量）避免数据竞争。
- ‌**适用场景**‌：大数据传输（如图像处理、高频交易）。
- ‌**系统调用**‌：`shmget()`、`shmat()`（Linux）。

---

#### ‌**2. 内存映射文件（Memory-Mapped File）**‌

- ‌**原理**‌：将文件映射到进程的虚拟内存空间，多进程共享同一文件映射。
- ‌**特点**‌：
  - 类似共享内存，但依赖文件作为持久化存储。
  - 适用于进程频繁读写文件场景。
- ‌**系统调用**‌：`mmap()`（Linux/Windows）。

---

#### ‌**3. 信号量（Semaphore）**‌

- ‌**原理**‌：通过计数器控制多进程对共享资源的访问权限。
- ‌**特点**‌：
  - 主要用于 ‌**同步**‌，而非直接传输数据。
  - 解决竞态条件（如多进程写同一文件）。
- ‌**系统调用**‌：`sem_init()`、`sem_wait()`（Linux）。

---

#### ‌**4. 消息队列（Message Queue）**‌

- ‌**原理**‌：内核维护的链表结构，进程通过发送/接收消息通信。
- ‌**特点**‌：
  - 支持 ‌**异步通信**‌，消息可指定类型。
  - 数据大小受内核限制，效率低于共享内存。
- ‌**系统调用**‌：`msgget()`、`msgsnd()`（Linux）。

---

#### ‌**5. 命名管道（FIFO）**‌

- ‌**原理**‌：基于文件系统的管道文件，允许无关进程通信。
- ‌**特点**‌：
  - 单向通信，需双向通信时创建两个管道。
  - 适用于长期稳定的进程间通信。
- ‌**系统调用**‌：`mkfifo()`（Linux）。

---

#### ‌**6. 匿名管道（Pipe）**‌

- ‌**原理**‌：内核缓冲区实现单向数据流，仅限父子进程或兄弟进程。
- ‌**特点**‌：
  - 简单轻量，但仅限 ‌**有亲缘关系**‌ 的进程。
  - Shell命令 `|` 的底层实现（如 `ls | grep txt`）。
- ‌**系统调用**‌：`pipe()`（Linux）。

---

#### ‌**7. 信号（Signal）**‌

- ‌**原理**‌：内核向进程发送事件通知（如 `SIGKILL`、`SIGTERM`）。
- ‌**特点**‌：
  - 仅传递 ‌**事件标识**‌，无法携带数据。
  - 适用于进程控制（如终止、挂起）。
- ‌**系统调用**‌：`kill()`、`signal()`（Linux）。

---

#### ‌**8. 套接字（Socket）**‌

- ‌**原理**‌：基于网络协议（TCP/IP或本地Unix域）的跨主机通信。
- ‌**特点**‌：
  - 通用性强，支持 ‌**跨网络通信**‌，但性能较低。
  - 典型应用：浏览器与服务器、分布式系统。
- ‌**系统调用**‌：`socket()`、`bind()`（Linux/Windows）。

# 20.线程之间的通信方式有哪些？

准确来说的是线程间数据同步方式

线程之间通信（更准确说是**同步与协作**）的方式与进程间通信（IPC）有显著不同。由于同一进程内的线程共享内存空间（堆、全局变量等），线程间可以直接通过共享内存交换数据，但需要同步机制来避免竞态条件和数据不一致问题。以下是线程间的主要同步与通信方式：

---

### ​**1. 共享变量（Shared Variables）​**

- ​**特点**：线程可以直接读写进程内的全局变量或堆内存。

- ​**风险**：不加控制会导致**数据竞争**​（Data Race）。

- ​**示例**：
  
  c
  
  ```c
  int counter = 0; // 全局变量
  void* thread_func(void* arg) {
      counter++; // 多个线程同时操作需同步
  }
  ```

- ​**注意**：必须通过锁或其他机制保护共享变量。

---

### ​**2. 互斥锁（Mutex）​**

- ​**用途**：确保同一时间只有一个线程访问共享资源（临界区）。

- ​**操作**：
  
  - `pthread_mutex_init()`：初始化锁。
  - `pthread_mutex_lock()`：加锁（阻塞直到获取锁）。
  - `pthread_mutex_unlock()`：解锁。
  - `pthread_mutex_trylock()`：非阻塞尝试加锁。

- ​**示例**：
  
  c
  
  ```c
  pthread_mutex_t mutex;
  void* thread_func(void* arg) {
      pthread_mutex_lock(&mutex);
      // 访问共享资源
      pthread_mutex_unlock(&mutex);
  }
  ```

- ​**注意**：避免死锁（如多个锁的顺序不一致）。

---

### ​**3. 条件变量（Condition Variable）​**

- ​**用途**：线程间通知机制，用于等待某个条件成立（如资源就绪）。

- ​**操作**：
  
  - `pthread_cond_init()`：初始化条件变量。
  - `pthread_cond_wait()`：释放锁并等待条件（需结合互斥锁）。
  - `pthread_cond_signal()`：唤醒一个等待线程。
  - `pthread_cond_broadcast()`：唤醒所有等待线程。

- ​**示例**​（生产者-消费者模型）：
  
  c
  
  ```c
  pthread_mutex_t mutex;
  pthread_cond_t cond;
  int data_ready = 0;
  
  void* consumer(void* arg) {
      pthread_mutex_lock(&mutex);
      while (!data_ready) {
          pthread_cond_wait(&cond, &mutex); // 自动释放锁并等待
      }
      // 消费数据
      pthread_mutex_unlock(&mutex);
  }
  
  void* producer(void* arg) {
      pthread_mutex_lock(&mutex);
      // 生产数据
      data_ready = 1;
      pthread_cond_signal(&cond); // 通知消费者
      pthread_mutex_unlock(&mutex);
  }
  ```

- ​**注意**：`pthread_cond_wait` 必须在循环中检查条件（避免虚假唤醒）。

---

### ​**4. 信号量（Semaphore）​**

- ​**用途**：控制对共享资源的访问数量（允许多个线程同时访问）。

- ​**操作**：
  
  - `sem_init()`：初始化信号量。
  - `sem_wait()`：信号量减1（若为0则阻塞）。
  - `sem_post()`：信号量加1。

- ​**示例**​（限制同时访问资源的线程数）：
  
  c
  
  ```c
  sem_t sem;
  sem_init(&sem, 0, 3); // 允许3个线程同时访问
  
  void* thread_func(void* arg) {
      sem_wait(&sem);
      // 访问资源
      sem_post(&sem);
  }
  ```

- ​**注意**：信号量可以跨进程（需设置 `pshared` 参数），但线程间通常使用 `0`（仅限进程内）。

---

### ​**5. 读写锁（Read-Write Lock）​**

- ​**用途**：区分读/写操作，允许多个读线程或单个写线程。
- ​**操作**：
  - `pthread_rwlock_init()`：初始化读写锁。
  - `pthread_rwlock_rdlock()`：读锁（共享）。
  - `pthread_rwlock_wrlock()`：写锁（独占）。
  - `pthread_rwlock_unlock()`：解锁。
- ​**适用场景**：读多写少的场景（如缓存系统）。

---

### ​**6. 屏障（Barrier）​**

- ​**用途**：让多个线程在某个点同步等待，直到所有线程都到达后才继续执行。

- ​**操作**：
  
  - `pthread_barrier_init()`：初始化屏障。
  - `pthread_barrier_wait()`：等待所有线程到达。

- ​**示例**​（并行计算的分阶段处理）：
  
  c
  
  ```c
  pthread_barrier_t barrier;
  pthread_barrier_init(&barrier, NULL, 3); // 等待3个线程
  
  void* thread_func(void* arg) {
      // 第一阶段计算
      pthread_barrier_wait(&barrier);
      // 所有线程到达后继续执行第二阶段
  }
  ```

---

### ​**7. 自旋锁（Spinlock）​**

- ​**用途**：通过忙等待（Busy-Waiting）实现轻量级锁，适用于临界区极短的场景。
- ​**操作**：
  - `pthread_spin_init()`：初始化自旋锁。
  - `pthread_spin_lock()`：加锁（循环尝试直到成功）。
  - `pthread_spin_unlock()`：解锁。
- ​**与互斥锁的区别**：
  - 互斥锁在阻塞时会让出 CPU。
  - 自旋锁在阻塞时持续占用 CPU，适合多核且临界区极短的场景。

---

### ​**8. 线程局部存储（Thread-Local Storage, TLS）​**

- ​**用途**：为每个线程提供独立的变量副本，避免共享变量的同步问题。

- ​**操作**：
  
  - `__thread` 关键字（GCC扩展）或 `pthread_key_create()`。

- ​**示例**​（C11标准）：
  
  c
  
  ```c
  _Thread_local int counter; // 每个线程有独立的 counter
  ```

---

### ​**选择同步机制的考虑因素**

1. ​**性能**：自旋锁适合短临界区，互斥锁适合长临界区。
2. ​**协作需求**：条件变量用于复杂等待/通知逻辑。
3. ​**并发度**：信号量控制并发数量，读写锁优化读多写少场景。
4. ​**代码复杂度**：屏障适合分阶段任务，TLS 避免共享状态。

# 21.介绍一下socket中的多路复用，及其他们的优缺点，epoll的水平和边缘触发模式

### 一.概述

- ​**`select`/`poll`**：适用于连接数少或跨平台场景，但性能差。
- ​**`epoll`**：Linux下高并发首选，支持海量连接，需根据业务选择LT或ET模式。
- ​**LT vs ET**：
  - LT模式适合对编程友好性要求高的场景。
  - ET模式适合需要极致性能的场景，但需谨慎处理数据读取和非阻塞IO。

### **二、`epoll`的触发模式**

`epoll` 有两种工作模式，通过 `epoll_event.events` 设置 `EPOLLLT`（默认）或 `EPOLLET` 来指定。

#### 1. ​**水平触发（Level-Triggered, LT）​**

- ​**触发条件**：  
  只要Socket缓冲区有数据可读或可写，`epoll_wait()`就会持续通知。
- ​**行为示例**：  
  假设Socket接收缓冲区有2KB数据：
  - 程序读取1KB后，剩余1KB未读。
  - 下次调用`epoll_wait()`时，仍会通知该Socket可读。
- ​**优点**：
  - 编程简单，无需一次性处理所有数据。
  - 避免因未处理完数据导致事件丢失。
- ​**缺点**：
  - 可能频繁触发事件，影响性能（尤其是高并发时）。

---

#### 2. ​**边缘触发（Edge-Triggered, ET）​**

- ​**触发条件**：  
  仅在Socket状态变化时触发一次（如从无数据变为有数据）。
- ​**行为示例**：  
  同样接收2KB数据：
  - 程序读取1KB后停止。
  - 下次调用`epoll_wait()`时，若没有新数据到达，**不会再次通知**。
- ​**优点**：
  - 减少事件触发次数，提升性能。
  - 适合高并发且需高效处理活跃连接的场景。
- ​**缺点**：
  - 必须一次性处理完所有数据，否则会丢失后续事件。
  - 需使用非阻塞IO（`read`/`write`循环到`EAGAIN`错误），否则可能阻塞其他Socket处理。

# 24.类的生命周期### **一、对象的创建与初始化**

#### 1. ​**构造函数（Constructor）​**

- 对象生命周期的起点是构造函数的调用。
- ​**作用**：初始化成员变量、分配资源（如内存、文件句柄等）。
- ​**分类**：
  - ​**默认构造函数**：无参数，如 `MyClass obj;`。
  - ​**参数化构造函数**：带参数的构造函数，如 `MyClass obj(10);`。
  - ​**拷贝构造函数**：通过已有对象初始化新对象，如 `MyClass obj2(obj1);`。
  - ​**移动构造函数（C++11）​**：转移资源所有权，如 `MyClass obj3(std::move(obj1));`。

#### 2. ​**初始化方式**

- ​**直接初始化**：`MyClass obj(10);`

- ​**拷贝初始化**：`MyClass obj = MyClass(10);`（可能触发拷贝构造函数优化）。

- ​**列表初始化（C++11）​**：`MyClass obj{10};` 或 `MyClass obj = {10};`。

- ​**成员初始化列表**：在构造函数中优先初始化成员变量。
  
  cpp
  
  ```cpp
  class MyClass {
      int a;
      std::string s;
  public:
      MyClass(int x, const std::string& str) : a(x), s(str) {}
  };
  ```

---

### ​**二、对象的存储类型与生命周期**

对象的生命周期取决于其存储类型：

#### 1. ​**自动存储期（栈对象）​**

- ​**声明方式**：函数内的局部变量（非`static`）。

- ​**生命周期**：从定义处开始，到作用域（如函数、代码块）结束时销毁。

- ​**示例**：
  
  cpp
  
  ```cpp
  void func() {
      MyClass obj; // 对象在栈上分配，func()结束时自动调用析构函数。
  }
  ```

#### 2. ​**动态存储期（堆对象）​**

- ​**声明方式**：通过 `new` 创建，`delete` 销毁。

- ​**生命周期**：手动控制，需显式释放内存，否则导致内存泄漏。

- ​**示例**：
  
  cpp
  
  ```cpp
  MyClass* ptr = new MyClass(10); // 对象在堆上分配
  delete ptr; // 显式销毁对象
  ```

#### 3. ​**静态存储期（全局/静态对象）​**

- ​**声明方式**：全局变量、命名空间作用域变量、`static` 局部变量。

- ​**生命周期**：
  
  - ​**全局对象**：程序启动时初始化，程序结束时销毁。
  - ​**静态局部对象**：首次执行到定义处时初始化，程序结束时销毁。

- ​**示例**：
  
  cpp
  
  ```cpp
  MyClass globalObj; // 全局对象
  
  void func() {
      static MyClass staticObj; // 静态局部对象
  }
  ```

#### 4. ​**线程局部存储（C++11）​**

- ​**声明方式**：使用 `thread_local` 关键字。

- ​**生命周期**：与所属线程的生命周期一致。

- ​**示例**：
  
  cpp
  
  ```cpp
  thread_local MyClass threadObj; // 每个线程有独立实例
  ```

---

### ​**三、对象的销毁与析构函数**

#### 1. ​**析构函数（Destructor）​**

- 对象生命周期的终点是析构函数的调用。
- ​**作用**：释放资源（如内存、文件句柄、网络连接等）。
- ​**语法**：`~MyClass() { /* 清理代码 */ }`。
- ​**规则**：
  - 析构函数在对象生命周期结束时自动调用。
  - 若未显式定义，编译器生成默认析构函数（仅释放成员变量，不处理动态资源）。

#### 2. ​**虚析构函数**

- ​**多态基类必须声明虚析构函数**，否则通过基类指针删除派生类对象时，只会调用基类的析构函数，导致派生类资源泄漏。

- ​**示例**：
  
  cpp
  
  ```cpp
  class Base {
  public:
      virtual ~Base() {} // 虚析构函数
  };
  class Derived : public Base {
      int* data;
  public:
      Derived() : data(new int[100]) {}
      ~Derived() { delete[] data; } // 正确释放派生类资源
  };
  
  Base* ptr = new Derived();
  delete ptr; // 调用Derived的析构函数
  ```

---

### ​**四、RAII（资源获取即初始化）​**

- ​**核心思想**：将资源（如内存、文件）的生命周期绑定到对象的生命周期。

- ​**实现方式**：在构造函数中获取资源，在析构函数中释放资源。

- ​**优势**：避免资源泄漏，即使发生异常也能保证资源释放。

- ​**示例**：
  
  cpp
  
  ```cpp
  class FileHandler {
      FILE* file;
  public:
      FileHandler(const char* path) : file(fopen(path, "r")) {}
      ~FileHandler() { if (file) fclose(file); }
  };
  
  void readFile() {
      FileHandler fh("data.txt"); // 文件在析构时自动关闭
  }
  ```

---

### ​**五、拷贝与移动语义**

#### 1. ​**拷贝语义**

- ​**拷贝构造函数**：`MyClass(const MyClass& other)`
- ​**拷贝赋值运算符**：`MyClass& operator=(const MyClass& other)`
- ​**深拷贝与浅拷贝**：需根据资源类型决定是否复制底层资源。

#### 2. ​**移动语义（C++11）​**

- ​**移动构造函数**：`MyClass(MyClass&& other)`
- ​**移动赋值运算符**：`MyClass& operator=(MyClass&& other)`
- ​**用途**：优化临时对象（右值）的资源转移，避免不必要的拷贝。

---

### ​**六、常见问题与注意事项**

1. ​**对象切片（Object Slicing）​**​
   
   - 将派生类对象赋值给基类对象时，派生类部分的数据丢失。
   - ​**解决**：使用基类指针或引用。

2. ​**悬垂指针/引用**​
   
   - 对象销毁后，仍通过指针或引用访问其数据。
   - ​**解决**：使用智能指针（`std::unique_ptr`、`std::shared_ptr`）。

3. ​**异常安全**​
   
   - 构造函数中抛出异常会导致对象未完全构造，但已分配的资源需手动释放。
   - ​**解决**：使用RAII封装资源。

4. ​**静态对象初始化顺序**​
   
   - 不同编译单元的全局静态对象初始化顺序不确定。
   - ​**解决**：使用局部静态对象（C++11后线程安全）。

---

### ​**七、生命周期管理的最佳实践**

1. ​**优先使用自动存储期对象**，避免手动内存管理。
2. ​**使用智能指针**​（如 `std::unique_ptr`、`std::shared_ptr`）管理堆对象。
3. ​**遵循RAII原则**，确保资源安全释放。
4. ​**为多态基类声明虚析构函数**。
5. ​**避免返回局部对象的指针/引用**，防止悬垂引用。
6. ​**使用移动语义优化性能**，减少不必要的拷贝。

# 25.父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？

| ​**函数类型**​ | ​**能否为虚函数**​ | ​**原因与后果**​                                 |
| ---------- | ------------ | ------------------------------------------- |
| 构造函数       | ​**否**​      | 语法禁止，虚表未初始化，构造顺序固定。强行声明会导致编译错误。             |
| 析构函数       | ​**是**​（必须）  | 确保多态对象的正确销毁。若基类析构函数非虚，通过基类指针删除派生类对象会导致资源泄漏。 |

# 26.多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？

# 27.描述一下面向过程和面向对象

### ​**对比总结**

| ​**维度**​    | ​**面向过程**​        | ​**面向对象**​         |
| ----------- | ----------------- | ------------------ |
| ​**核心单元**​  | 函数                | 对象                 |
| ​**设计目标**​  | 流程化解决问题           | 模块化协作解决问题          |
| ​**数据与逻辑**​ | 数据与函数分离           | 数据与方法封装在对象中        |
| ​**代码复用**​  | 通过函数库复用           | 通过继承、组合、多态复用       |
| ​**适用场景**​  | 小型程序、算法实现、性能敏感场景  | 中大型项目、复杂业务系统、GUI开发 |
| ​**扩展性**​   | 修改函数或全局数据可能影响其他部分 | 通过新增类或方法扩展，不影响现有代码 |

---

### ​**如何选择编程范式？**

1. ​**面向过程**：
   
   - 适合逻辑简单、注重效率的任务（如数学计算、脚本工具）。
   - 示例：操作系统内核、嵌入式系统、数值计算库。

2. ​**面向对象**：
   
   - 适合业务复杂、需长期维护的系统（如Web应用、游戏开发）。
   - 示例：电商平台、图形编辑器、企业级框架。

实际开发中，两种范式常结合使用。例如，在面向对象系统中，某些底层模块可能用面向过程实现以提高性能。

# 28.C++中左值和右值是什么？++i是左值还是右值，++i和i++哪个效率更高？

- ​**左值（`++i`）​**：返回递增后的对象本身，因此为左值，可修改、有持久身份，适用于高效修改自身。
- ​**右值（`i++`）​**：返回递增前的副本，为临时值，因此为右值，仅用于需要保留原始值的场景。
- ​**效率**：对自定义类型，优先使用 `++i`；对内置类型，两者无差异

# 29.介绍一下vector、list的底层实现原理和优缺点

| ​**特性**​      | `vector`    | `list`        |
| ------------- | ----------- | ------------- |
| ​**底层结构**​    | 动态数组（连续内存）  | 双向链表（非连续内存）   |
| ​**随机访问**​    | O(1)        | O(n)          |
| ​**尾部操作**​    | 均摊 O(1)     | O(1)          |
| ​**中间插入/删除**​ | O(n)        | O(1)（需先遍历到位置） |
| ​**内存占用**​    | 低（仅需容量指针）   | 高（每个节点含两个指针）  |
| ​**缓存友好性**​   | 高           | 低             |
| ​**迭代器失效**​   | 扩容后所有迭代器失效  | 仅被删除元素的迭代器失效  |
| ​**适用场景**​    | 随机访问、尾部操作为主 | 频繁任意位置插入/删除   |

## **一、`vector`的底层实现与特点**

#### ​**底层实现**：

- ​**动态数组**：元素在内存中**连续存储**，支持随机访问（通过下标直接计算地址）。
- ​**扩容机制**：当元素数量超过当前容量（`capacity`）时，会重新分配一块更大的内存（通常为当前容量的**1.5或2倍**），将原有元素拷贝到新内存，然后释放旧内存。
- ​**内存管理**：通过三个指针实现：
  - `start`：指向首元素。
  - `finish`：指向最后一个元素的下一个位置。
  - `end_of_storage`：指向内存块的末尾。

## 二、`list`的底层实现与特点

#### ​**底层实现**：

- ​**双向链表**：每个元素存储在独立节点中，节点包含：
  - 数据域。
  - `prev`指针：指向前驱节点。
  - `next`指针：指向后继节点。
- ​**内存分配**：每次插入新元素时动态分配节点内存，删除时释放

# 30.静态变量在哪里初始化？在哪一个阶段初始化？

# （都存放在全局区域）

| **静态变量类型**​ | ​**初始化位置**​ | ​**初始化阶段**​          | ​**注意事项**​       |
| ----------- | ----------- | -------------------- | ---------------- |
| 全局静态变量      | 静态存储区       | `main`函数前（静态/动态初始化）  | 避免跨编译单元依赖        |
| 局部静态变量      | 静态存储区       | 首次执行到声明处时            | C++11后线程安全       |
| 类的静态成员变量    | 静态存储区       | `main`函数前（需在类外显式初始化） | 必须类外定义，避免头文件中初始化 |

# 31.如何实现多进程？

# 32.空对象指针为什么能调用函数？

### **一、为什么语法上允许调用？**

1. ​**成员函数的本质**：  
   成员函数在编译时会被转换为普通函数，并隐式添加一个`this`指针参数。例如：
   
   cpp
   
   ```cpp
   class MyClass {
   public:
      void func() { /* ... */ } 
      // 编译器转换为：void func(MyClass* this) { ... }
   };
   ```

2. ​**函数调用机制**：  
   当通过指针调用成员函数时，编译器仅需将指针值作为`this`参数传递，**不会立即解引用指针**。因此，即使指针为`nullptr`，只要函数内部不访问对象数据，代码可能暂时不会崩溃。

3. 空指针调用成员函数为何可能不崩溃
   当通过空指针调用成员函数时，是否崩溃取决于函数内部是否访问了 this 指针指向的成员数据：

如果成员函数内部没有使用任何非静态成员变量，则即使 this 指针为空，函数调用也不会触发解引用空指针的操作：

```cpp
class MyClass {
public:
    void safeFunc() { 
        std::cout << "This function does not use member variables." << std::endl;
    }
};

int main() {
    MyClass* ptr = nullptr;
    ptr->safeFunc();  // 可能不会崩溃
    return 0;
}
```

# 33.shared_ptr线程安全吗？

`shared_ptr` 的引用计数通过原子操作实现，**跨线程的拷贝、赋值和析构是线程安全的**。但对指针指向的数据的访问不是线程安全的

配合shared_pt使用，不会增加引用计数，可以用来解决shared_ptr循环引用的问题，可以通过lock()方法获取shared_ptr.

使用建议：

优先使用unique_ptr，除非确实需要共享所有权
创建智能指针时优先使用make_unique/make_shared而不是直接new
使用weak_ptr来避免循环引用
注意避免悬空指针（比如把原始指针存起来后智能指针释放了资源

# 34.push_back()左值和右值的区别是什么？

#### ‌**1. 左值（lvalue）示例**‌

std::vector<std::string> vec; 

std::string s = "Hello"; vec.push_back(s);  // 左值：拷贝构造，s 的值被复制到容器中，s 自身不变

#### ‌**2. 右值（rvalue）示例**‌

`vec.push_back("World");          // 右值：移动构造（临时字符串）

 vec.push_back(std::move(s));     // 右值：显式转移所有权，s 的内容被“掏空”`

push右值 调用移动构造，不拷贝，效率高

# 35.move底层是怎么实现的？

‌**`std::move` 的核心逻辑是类型转换**‌。它不进行任何实际的数据移动，而是将对象标记为“可移动的右值”，从而触发移动语义（如调用移动构造函数/移动赋值运算符）。

template <typename T>
constexpr std::remove_reference_t<T>&& move(T&& arg) noexcept {
    return static_cast<std::remove_reference_t<T>&&>(arg);
}

# 36.完美转发的原理是什么？

完美转发是C++中一种高级的技术，用于在函数模板中转发参数至另一个函数，同时保持所有参数的值类别（[左值](https://so.csdn.net/so/search?q=%E5%B7%A6%E5%80%BC&spm=1001.2101.3001.7020)、右值）和其他属性（如`const`修饰符）不变。这一技术主要通过模板和`std::forward`实现，并在泛型编程中尤为重要，因为它允许函数模板在不丢失任何参数信息的前提下传递参数。

std::forward是C++11引入的一个模板函数，主要用于实现参数的完美转发。它的核心作用是在模板函数中保持参数的原始值类别（左值或右值）。std::forward通常与通用引用（Universal References，形式为T&&）一起使用，这种引用可以绑定到左值或右值上。通过使用std::forward，可以确保在函数模板中转发参数时，保持其左值或右值属性不变。

```cpp
template<typename T>
T&& Forward(T&& f) {
    return static_cast<T&&>(f);
}
```

这里，变量作为参数在传递给forward时会进行一次**引用折叠**，在return时又会进行一次**引用折叠**。因此在**实参**为右值引用时，经过**两次引用折叠**结果为右值引用，而如果实参为左值引用，那么两次引用折叠后结果仍为左值引用。

# 37.空类中有什么函数？

| 函数类型    | 函数签名示例                           | C++版本  |
| ------- | -------------------------------- | ------ |
| 默认构造函数  | `Empty::Empty()`                 | 所有     |
| 析构函数    | `Empty::~Empty()`                | 所有     |
| 拷贝构造函数  | `Empty::Empty(const Empty&)`     | 所有     |
| 拷贝赋值运算符 | `Empty& operator=(const Empty&)` | 所有     |
| 移动构造函数  | `Empty::Empty(Empty&&)`          | C++11+ |
| 移动赋值运算符 | `Empty& operator=(Empty&&)`      | C++11+ |

# 38.explicit用在哪里？有什么作用？

`explicit` 关键字在 C++ 中用于修饰构造函数，以防止隐式类型转换或隐式构造函数调用。

需要注意的是，`explicit` 关键字主要用于防止单参数构造函数的隐式转换，对于多参数的构造函数，隐式转换本身就不可能发生，因此在多参数构造函数中使用 `explicit` 是没有意义的

# 39.成员变量初始化的顺序是什么？

| 初始化阶段   | 顺序规则          | 是否可干预    |
| ------- | ------------- | -------- |
| 基类初始化   | 按继承声明顺序（从左到右） | 声明顺序不可修改 |
| 成员变量初始化 | 按类中声明顺序       | 声明顺序不可修改 |
| 构造函数赋值  | 按初始化列表顺序覆盖默认值 | 可自由调整    |

# 40.指针占用的大小是多少？

# 41.野指针和内存泄漏是什么？如何避免？

# 42.malloc和new的区别是什么？

# 43.多线程会发生什么问题？线程同步有哪些手段？

# 44.什么是STL？

# 45.对比迭代器和指针的区别

# 46.线程有哪些状态，线程锁有哪些？

# 47.解释说明一下map和unordered_map

# 48.vector中的push_back()和emplace_back()的区别、以及使用场景

- `push_back()` 需要先构造对象再拷贝/移动到容器。
- `emplace_back()` 通过‌**完美转发**‌直接在容器内存中构造对象。

| ‌**特性**‌     | ‌**`push_back()`**‌   | ‌**`emplace_back()`**‌ |
| ------------ | --------------------- | ---------------------- |
| ‌**参数类型**‌   | 接受已构造的‌**对象**‌（拷贝或移动） | 接受构造对象所需的‌**参数列表**‌    |
| ‌**临时对象生成**‌ | 可能生成临时对象（隐式转换或构造）     | 直接在容器内存中构造对象，无临时对象     |
| ‌**性能开销**‌   | 可能多一次拷贝/移动操作          | 避免拷贝/移动，对复杂对象更高效       |
| ‌**适用场景**‌   | 已有对象或需要显式移动语义时        | 直接通过参数构造对象时            |

# 49.如何实现线程安全，除了加锁还有没有其他的方式？

# 50.vector扩容，resize和reserve的区别

# 51.vector扩容为了避免重复扩容做了哪些机制？

# 52.C++中空类的大小是多少？

#### ‌**标准规定**‌

C++ 标准明确要求：‌**任何类对象的大小必须至少为 1 字节**‌。

# 53.weak_ptr是怎么实现的？

# 54.虚函数的底层原理是什么？

虚函数通过‌**vtable+vptr**‌实现动态绑定，其本质是：

1. ‌**编译期**‌构建类型函数映射表
2. ‌**运行期**‌通过指针间接寻址实现多态
3. ‌**空间换时间**‌的设计取舍，为面向对象提供核心支持

# 55.一个函数f(int a,int b)，其中a和b的地址关系是什么？

# 56.移动构造和拷贝构造的区别是什么？

# 57.lamda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？

# 58.哈希碰撞的处理方法

# 59.unordered_map的扩容过程

# 60.vector如何判断应该扩容？（size和capacity）

# 61.构造函数是否能声明为虚函数？为什么？什么情况下为错误？

# 62.类中static函数是否能声明为虚函数？

# 63.哪些函数不能被声明为虚函数？

# 64.如何保证类的对象只能被开辟在堆上？

将构造函数声明为私有、单例

# 65.讲讲你理解的虚基类

# 66.C++哪些运算符不能被重载？

# 67.动态链接和静态链接的区别，动态链接的原理是什么？

# 68.C++中怎么编译C语言代码？

# 69.未初始化的全局变量和初始化的全局变量放在哪里？

- ‌**初始化的全局变量**‌  
  存储在 ‌**`.data` 段**‌（数据段），包含显式初始化的值（如 `int a = 5;`）。

- ‌**未初始化的全局变量**‌  
  存储在 ‌**`.bss` 段**‌（Block Started by Symbol），系统默认初始化为零值（如 `int b;` 实际为 `b=0`）。

`.bss` 段不占用可执行文件的实际磁盘空间，仅记录所需大小，由系统在加载时分配并清零。

# 70.说一下内联函数及其优缺点

调用该函数时，将函数的代码直接插入到调用点处，而不是进行常规的函数调用。这样可以减少函数调用时的开销，如参数压栈、跳转和返回等操作

# 71.C++11中的auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？

# 72.map和set的区别和底层实现是什么？map取值的 find，[]，at方法的区别

map是键值对，set只有键，底层都是红黑树

删改查都是 ‌O(log n)

at有越界检查功能

# 73.详细说一说fcntl的作用

# 74.C++的面向对象主要体现在那些方面？

# 75.介绍一下extern C关键字，为什么会有这个关键字？

# 76.讲一讲迭代器失效及其解决方法

# 77.编译器是如何实现重载的？

C++编译器实现函数重载的核心机制是通过**名称修饰（Name Mangling）​**和**多阶段重载决议**完成的

# 78.什么是函数调用约定？

[函数调用](https://so.csdn.net/so/search?q=%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8&spm=1001.2101.3001.7020)约定（**Calling Convention**）是在[程序设计](https://so.csdn.net/so/search?q=%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1&spm=1001.2101.3001.7020)中定义函数如何调用和返回的一套规则。它规定了函数参数的传递方式、返回值的处理、堆栈的管理以及函数名的修饰方式等。不同的调用约定可能会影响程序的性能和可移植性，因此理解它们对于高效编程和调试非常重要

C/C++默认的 ：参数是从**右到左**依次压入堆栈

# 79.使用条件变量的时候需要注意什么？

配合mutex

# 80.类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？

# 81.强制类型转换有哪几种类型，分别有什么特点？原理是什么？

Static_cast：用于数据类型的强制转换，强制将一种数据类型转化为另一种数据类型。

Const_cast：用于强制去除类似于const这种不能被修改的常数特性。

Reinterpret_cast：用于改变指针或引用的类型，将指针或引用类型转换成一个足够长的整形，将整形转换为指针或引用。

Dynamic_cast：其他三种都是在编译时完成的，它是在运行时处理的，运行时要进行类型检查。转换class常用

# 82.回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？

# 83.Linux中的信号有哪些？

# 84.什么是尾递归？

递归放在函数最后，无栈溢出风险，可优化为迭代写法

# 85.为什么会有栈溢出，为什么栈会设置容量？

# 86.二叉树和平衡二叉树的区 别

平衡二叉树可避免退化为链表

# 87.平衡二叉树的优缺点

# 88.什么是this指针，为什么存在this指针？

# 89.什么是重载、重写、隐藏？

# 90.静态成员函数可以是虚函数吗？为什么？

# 91.构造函数可以为虚函数吗？为什么？

# 92.make_shared函数的优点，缺点？

# 93.函数调用进行的操作



设计模式

### **一、创建型模式​**​

1. ​**​单例模式（Singleton）​**​
   
   - ​**​作用​**​：确保一个类仅有一个实例，并提供全局访问点，常用于配置管理、日志服务等场景。
   
   - ​**​C++ 实现要点​**​：通过私有构造函数和静态实例变量实现线程安全的单例（如双重检查锁或局部静态变量）
   
   - ​**​示例​**​：数据库连接池、全局配置管理器。

2. ​**​工厂方法模式（Factory Method）​**​
   
   - ​**​作用​**​：将对象的创建延迟到子类，避免客户端直接依赖具体类。适用于需要动态扩展对象类型的场景
   
   - ​**​C++ 实现​**​：通过抽象基类定义接口，子类实现具体对象的创建逻辑。
   
   - ​**​示例​**​：图形库中根据用户输入创建不同形状（圆形、矩形）。

3. ​**​抽象工厂模式（Abstract Factory）​**​
   
   - ​**​作用​**​：创建一系列相关或依赖对象的接口，隐藏具体实现类，适用于跨平台UI组件、数据库访问等需要兼容性的场
   
   - ​**​示例​**​：跨操作系统（Windows/Linux）的按钮和文本框组件工厂。

---

### ​**​二、结构型模式​**​

1. ​**​适配器模式（Adapter）​**​
   
   - ​**​作用​**​：将不兼容的接口转换为客户端期望的接口，常用于整合第三方库或遗留代码
   
   - ​**​C++ 实现​**​：通过继承或组合现有类，包装其接口。
   
   - ​**​示例​**​：将旧版日志系统的接口适配到新系统。

2. ​**​装饰器模式（Decorator）​**​
   
   - ​**​作用​**​：动态地为对象添加额外职责，避免通过继承导致类膨胀
   
   - ​**​C++ 实现​**​：通过组合和继承结合，装饰器类包裹原始对象并扩展功能。
   
   - ​**​示例​**​：为数据流动态添加加密、压缩功能。

3. ​**​代理模式（Proxy）​**​
   
   - ​**​作用​**​：控制对对象的访问，常用于延迟加载、权限控制或远程调用
   
   - ​**​示例​**​：图片懒加载代理、网络请求的缓存代理。

---

### ​**​三、行为型模式​**​

1. ​**​观察者模式（Observer）​**​
   
   - ​**​作用​**​：定义对象间的一对多依赖关系，当主题对象状态变化时自动通知观察者，适用于事件驱动系统（如GUI、实时数据监控）
   
   - ​**​C++ 实现​**​：通过主题（Subject）维护观察者列表，提供注册/通知接口。
   
   - ​**​示例​**​：股票价格变动时通知多个交易终端。

2. ​**​策略模式（Strategy）​**​
   
   - ​**​作用​**​：将算法封装为独立类，支持运行时动态切换，适用于需要灵活调整业务逻辑的场景（如排序算法、支付方式）
- ​**​C++ 实现​**​：通过接口定义策略，具体策略类实现不同算法。

- ​**​示例​**​：电商系统中根据用户类型选择不同的折扣策略。
3. ​**​模板方法模式（Template Method）​**​
   
   - ​**​作用​**​：定义算法骨架，将某些步骤延迟到子类实现，适用于框架设计或标准化流程
- ​**​示例​**​：游戏引擎中固定渲染流程（初始化→更新→渲染→销毁），子类实现具体渲染细节。

## 工厂模式例子

工厂模式是一种创建型设计模式，通过封装对象的创建过程，将客户端代码与具体类解耦

```
// 抽象产品
class Phone {
public:
    virtual void start() = 0;
};

// 具体产品
class XiaomiPhone : public Phone {
public:
    void start() override { cout << "小米手机启动" << endl; }
};

class HuaweiPhone : public Phone {
public:
    void start() override { cout << "华为手机启动" << endl; }
};

// 工厂类
class PhoneFactory {
public:
    static Phone* createPhone(const string& type) {
        if (type == "xiaomi") return new XiaomiPhone();
        if (type == "huawei") return new HuaweiPhone();
        return nullptr;
    }
};

// 客户端调用
int main() {
    Phone* phone = PhoneFactory::createPhone("huawei");
    phone->start();  // 输出：华为手机启动
    delete phone;
    return 0;
}
```

## 观察者模式例子：

​观察者模式：定义对象间的一对多依赖关系，当主题对象状态变化时自动通知观察者，适用于事件驱动系统（如GUI、实时数据监控）

定义对象间的一对多依赖关系，当一个对象（主题）状态变化时，自动通知所有依赖它的观察者

```
// 观察者接口
class Observer {
public:
    virtual void update() = 0;
};

// 具体观察者
class ConcreteObserver : public Observer {
public:
    void update() override { 
        std::cout << "Observer received notification!" << std::endl; 
    }
};

// 主题接口
class Subject {
public:
    virtual void registerObserver(Observer* o) = 0;
    virtual void removeObserver(Observer* o) = 0;
    virtual void notifyObservers() = 0;
}; 

// 具体主题
class ConcreteSubject : public Subject {
private:
    std::list<Observer*> observers;
public:
    void registerObserver(Observer* o) override { observers.push_back(o); }
    void removeObserver(Observer* o) override { observers.remove(o); }
    void notifyObservers() override {
        for (auto& o : observers) o->update();
    }
    void changeState() { 
        std::cout << "Subject state changed!" << std::endl; 
        notifyObservers();
    }
};
```

## 适配器模式：

适配器模式通过 ​**​转换接口​**​，解决现有类与目标接口不兼容的问题

```
#include <iostream>

// 目标接口：国标插座
class CN_Socket {
public:
    virtual void charge() = 0;
};

// 被适配者：美标插头
class US_Plug {
public:
    void usCharge() {
        std::cout << "美标插头充电中..." << std::endl;
    }
};

// 类适配器（继承目标接口和被适配者）
class Adapter : public CN_Socket, private US_Plug {
public:
    void charge() override {
        std::cout << "适配器将国标转换为美标：";
        usCharge();  // 调用被适配者的方法
    }
};

int main() {
    CN_Socket* socket = new Adapter();
    socket->charge();  // 输出：适配器将国标转换为美标：美标插头充电中...
    delete socket;
    return 0;
}
```

# lambda:

- `[=]`：按值捕获所有外部变量。
- `[&]`：按引用捕获所有外部变量。
- `[this]`：捕获当前类的`this`指针（访问成员变量）。

```
int a = 10, b = 20;
// 值捕获a，引用捕获b
auto lambda = [a, &b]() { b += a; };
lambda();  // b变为30

// 隐式捕获所有变量（值捕获）
auto sum = [=]() { return a + b; };

// 隐式捕获所有变量（引用捕获）
auto modify = [&]() { a++; b++; };
```

# 模板

## 函数模板

```
template <typename T>
T max(T a, T b) {
    return (a > b) ? a : b;
}
```

类模板

```
template <typename T>
class Box {
private:
    T value;
public:
    Box(T val) : value(val) {}
    T getValue() {
        return value;
    }
};
```

使用

```
int main() {
    Box<int> intBox(100);  // 使用int类型
    Box<double> doubleBox(100.5);  // 使用double类型

   std::cout << "intBox value: " << intBox.getValue() << std::endl;
  std::cout << "doubleBox value: " << doubleBox.getValue() << std::endl;
   return 0;



}
```
