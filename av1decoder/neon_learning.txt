
arm64  SIMD 汇编学习笔记
指令 XX XX2 这样两个一组的指令，不带2的操作低位，带2的操作高位，这里的高位 低位针对的是 source寄存器

arm 寄存器
X/W寄存器：用于一般计算和整数运算。
X是64位，W是对应的低32位。
V寄存器：用于向量和浮点运算，128位宽。
Q寄存器：也是用于向量运算，别名表示128位的V寄存器。
D寄存器：用于64位的向量运算和浮点运算，表示V寄存器的低64位。

也就说一般写的就是 

X 和 V
如果用到w ，则用作通用寄存器，传递参数等常规用途

ld1 指令格式
ld1 {Vt.<T>}[index], [Xn|SP], Xm
.<T>
举例
.b - 8位无符号整数（Unsigned byte）
.h - 16位无符号整数（Unsigned halfword）
.s - 32位单精度浮点数（Single precision float） - 已经提及
.d - 64位双精度浮点数（Double precision float）
.8 或 .8b - 8位有符号/无符号整数，具体取决于上下文，通常用于表示8位整数向量
.16 或 .16b - 16位有符号/无符号整数向量

.4s - 4个32位单精度浮点数组成的向量
.2d - 2个64位双精度浮点数组成的向量
依次类推


ARM32（AArch32）：指令通常以“V”开头，如VADD, VMUL等。
ARM64（AArch64）：指令通常以“ADD”, “MUL”等标准操作符开头，并且有更一致的命名规则，例如ADD, MLA, SADDL等。
add 系列
add
sqadd
usqadd
vadd.8h
vadd.16b 

vswp vtrn 这两个 arch64里面是没有的，arch里面用 trn1 trn2



trn1（Transpose 1）
trn1指令将两个源向量的对应元素交错地放入目标向量中。具体来说，对于每个源向量中的元素，trn1会取第一个源向量的第一个元素与第二个源向量的第一个元素，然后是第一个源向量的第二个元素与第二个源向量的第二个元素，以此类推。如果考虑的是半字（.4h）或单字（.2s）操作，它就是按照这种一一对应的交错方式进行排列。

例如，如果有两个源向量：

源向量1: [a0, a1, a2, a3]
源向量2: [b0, b1, b2, b3]
执行trn1操作后，结果会是：

结果向量: [a0, b0, a1, b1]
trn2（Transpose 2）
与trn1类似，trn2也是进行元素转置，但它的交错方式不同。trn2会取第一个源向量的第一个元素与第二个源向量的第二个元素，接着是第一个源向量的第二个元素与第二个源向量的第一个元素，依此类推。这相当于在垂直方向上错开一位进行元素的交换。

继续上面的例子，如果对相同的源向量执行trn2操作：

源向量1: [a0, a1, a2, a3]
源向量2: [b0, b1, b2, b3]
执行trn2操作后，结果会是：

结果向量: [a0, b1, a1, b0]


mov             v19.16b, v23.16b  arch 64中 ，mov复制向量，必须是以 .b 也就是8位为单位

rev64 
例如
rev64           v7.8h,   v7.8h
前
v7 = [H0, H1, H2, H3, H4, H5, H6, H7]
后
v7 = [H3, H2, H1, H0, H7, H6, H5, H4]


ext
此指令从第二个源SIMD和FP寄存器中提取最低位的向量元素，从第一个源SIMD和FP寄存器中提取最高位的向量元素，然后将这些结果连接成一个新的向量，并将其写入目标SIMD和FP寄存器中。index值指定了从第一个源寄存器中开始提取的最低位向量元素，随后连续的元素依次从第一个源寄存器和第二个源寄存器中提取，直到填满目标向量。
ext             v7.16b,  v7.16b,  v7.16b,  #8
这就相当于把自己的内容交错存储了


.irp i x x x 

.endr 
相当于汇编中的for 循环


srshr 指令在 ARM64 架构中用于无符号右移并舍弃溢出的位