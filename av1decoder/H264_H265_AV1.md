# 1.块划分方式

## h264:

 每个宏块大小固定16x16

子宏块采用四叉树划分或者二分划分

B_Skip 类型宏块：

- 无像素残差，无运动矢量残差（MVD）。 解码时，通过Direct预测模式（时间或空间）计算出前、后向MV后，直接利用前、后向MV得到像素预测值。像素重构值=像素预测值

P_Skip 类型宏块：

- 无像素残差，无运动矢量残差（MVD）。也就是COPY宏块。直接利用预测 MV 得到像素预测值。像素重构值=像素预测值。

B_Direct_16x16 类型宏块 ：

- 有像素残差，无运动矢量残差（MVD）。解码时，通过Direct预测模式（时间或空间）计算出前、 后MV后，利用前、后MV得到像素预测值。然后，像素重构值=像素预测值+像素残差解码值。

## h265:

 采用四叉树划分或者二分划分，最大64X64

## av1: 

四叉树 + 二分 + NX4N +  一边二分一边不分（T字） 最大128x128（superblock）

partition：相当于CTU的定位，固定大小（64x64，启用superblock的时候为128X 128）

block

# 2.参数集：

## h264:	

​	SPS + PPS 

### sps ：

**profile_idc**、 **level_idc** 指明所用 profile、level。
constraint_set0_flag 等于 1 时表示必须遵从附录 A.2.1 所指明的所有制约条件。等于 0 时表示不必遵从所有条件。
**constraint_set1_flag** 等于 1 时表示必须遵从附录 A.2.2 所指明的所有制约条件。等于 0 时表示不必遵从所有条件。
**constraint_set2_flag** 等于 1 时表示必须遵从附录 A.2.3 所指明的所有制约条件。等于 0 时表示不必遵从所有条件。
注意： 当 constraint_set0_flag,constraint_set1_flag,constraint_set2_flag 中的两个以上等于 1 时，A.2
中的所有制约条件都要被遵从。

**reserved_zero_5bits** 在目前的标准中本句法元素必须等于 0，其他的值保留做将来用，解码器应该忽略本句法元素的值。
**seq_parameter_set_id** 指明本序列参数集的 id 号，这个 id 号将被 picture 参数集引用，本句法元素的值应该在[0，31]。
注意：当编码器需要产生新的序列参数集时，应该使用新的 seq_parameter_set_id,即使用新的序列参
数集，而不是去改变原来的参数集中的内容

**log2_max_frame_num_minus4** 这个句法元素主要是为读取另一个句法元素 frame_num (在sliceheader中)服务的，frame_num 

是最重要的句法元素之一，它标识所属图像的解码顺序。可以在句法表看到，fram-num的解码函数是 ue（v），函数中的 v 在这里指定：
		
$$
v = log2_max_frame_num_minus4 + 4
$$
从另一个角度看，这个句法元素同时也指明了 frame_num 的所能达到的最大值：
		
$$
MaxFrameNum = 2( log2_max_frame_num_minus4 + 4 )
$$
变量 MaxFrameNum 表示 frame_num 的最大值，在后文中可以看到，在解码过程中它也是一个非常
重要的变量。
值得注意的是 frame_num 是循环计数的，即当它到达 MaxFrameNum 后又从 0 重新开始新一轮
的计数。解码器必须要有机制检测这种循环，不然会引起类似千年虫的问题，在图像的顺序上造成
混乱。在第八章会详细讲述 H.264 检测这种循环的机制。

**pic_order_cnt_type** 指明了 poc (picture order count) 的编码方法，poc 标识图像的播放顺序。由于
H.264 使用了 B 帧预测，使得图像的解码顺序并不一定等于播放顺序，但它们之间存在一定的映射
关系。poc 可以由 frame-num 通过映射关系计算得来，也可以索性由编码器显式地传送。H.264 中一
共定义了三种 poc 的编码方法，这个句法元素就是用来通知解码器该用哪种方法来计算 poc。而以下
的几个句法元素是分别在各种方法中用到的数据。
在如下的视频序列中本句法元素不应该等于 2:

- 一个非参考帧的接入单元后面紧跟着一个非参考图像(指参考帧或参考场)的接入单元
- 两个分别包含互补非参考场对的接入单元后面紧跟着一个非参考图像的接入单元.
- 一个非参考场的接入单元后面紧跟着另外一个非参考场,并且这两个场不能构成一个互补场对







**log2_max_pic_order_cnt_lsb_minus4** 指明了变量 MaxPicOrderCntLsb 的值:
$$
MaxPicOrderCntLsb = 2( log2_max_pic_order_cnt_lsb_minus4 + 4 )
$$
该变量在 pic_order_cnt_type = 0 时使用。

该变量在 pic_order_cnt_type = 0 时使用。

**delta_pic_order_always_zero_flag** 等于 1 时,句法元素 delta_pic_order_cnt[0]和 delta_pic_order_cnt[1]不在片头出现,并且它们的值默认为 0; 本句法元素等于 0 时,上述的两个句法元素将在片头出现。offset_for_non_ref_pic 被用来计算非参考帧或场的 picture order count (在 8.2.1),本句法元素的值应
该在[-231 , 231 – 1]。

**offset_for_top_to_bottom_field** 被用来计算帧的底场的 picture order count (在 8.2.1), 本句法元素的值应该在[-231 , 231 – 1]。

**num_ref_frames_in_pic_order_cnt_cycle** 被用来解码 picture order count (在 8.2.1),本句法元素的值应该在[0,255]。

**offset_for_ref__frame**[i] 在 picture order count type=1 时用，用于解码 POC，本句法元素对循环num_ref_frames_in_pic_order_cycle 中的每一个元素指定一个偏移。

**num_ref_frames** 指定参考帧队列可能达到的最大长度，解码器依照这个句法元素的值开辟存储区，这个存储区用于存放已解码的参考帧，H.264 规定最多可用 16 个参考帧，本句法元素的值最大为 16。值得注意的是这个长度以帧为单位，如果在场模式下，应该相应地扩展一倍。

**gaps_in_frame_num_value_allowed_flag** 这个句法元素等于 1 时，表示允许句法元素 frame_num 可以不连续。当传输信道堵塞严重时，编码器来不及将编码后的图像全部发出，这时允许丢弃若干帧图像。在正常情况下每一帧图像都有依次连续的 frame_num 值，解码器检查到如果 frame_num 不连续，便能确定有图像被编码器丢弃。这时，解码器必须启动错误掩藏的机制来近似地恢复这些图像，因为这些图像有可能被后续图像用作参考帧。当这个句法元素等于 0 时，表不允许 frame_num 不连续，即编码器在任何情况下都不能丢弃图像。这时，H.264 允许解码器可以不去检查 frame_num 的连续性以减少计算量。这种情况下如果依然发生 frame_num 不连续，表示在传输中发生丢包，解码器会通过其他机制检测到丢包的发生，然后启动错误掩藏的恢复图像。

**pic_width_in_mbs_minus1** 本句法元素加 1 后指明图像宽度，以宏块为单位：
		PicWidthInMbs = pic_width_in_mbs_minus1 + 1
通过这个句法元素解码器可以计算得到亮度分量以像素为单位的图像宽度：
		PicWidthInSamplesL = PicWidthInMbs * 16
从而也可以得到色度分量以像素为单位的图像宽度：
		PicWidthInSamplesC = PicWidthInMbs * 8
以上变量 PicWidthInSamplesL、PicWidthInSamplesC 分别表示图像的亮度、色度分量以像素为单位的宽。H.264 将图像的大小在序列参数集中定义，意味着可以在通信过程中随着序列参数集动态地改变图像的大小，在后文中可以看到，甚至可以将传送的图像剪裁后输出。

**pic_height_in_map_units_minus1** 本句法元素加 1 后指明图像高度：
PicHeightInMapUnits = pic_height_in_map_units_minus1 + 1
PicSizeInMapUnits = PicWidthInMbs * PicHeightInMapUnits
图像的高度的计算要比宽度的计算复杂，因为一个图像可以是帧也可以是场，从这个句法元素可以在帧模式和场模式下分别计算出出亮度、色度的高。值得注意的是，这里以 map_unit 为单位，map_unit的含义由后文叙述。

**frame_mbs_only_flag** 本句法元素等于 0 时表示本序列中所有图像的编码模式都是帧，没有其他编码模式存在；本句法元素等于 1 时 ，表示本序列中图像的编码模式可能是帧，也可能是场或帧场自适应，某个图像具体是哪一种要由其他句法元素决定。结合 map_unit 的含义，这里给出上一个句法元素 pic_height_in_map_units_minus1 的进一步解析步骤：当 frame_mbs_only_flag 等于１，pic_height_in_map_units_minus1 指的是一个 picture 中帧的高度；当frame_mbs_only_flag 等于０，pic_heght_in_map_units_minus1 指的是一个 picture 中场的高度，所以可以得到如下以宏块为单位的图像高度：
FrameHeightInMbs = ( 2 – frame_mbs_only_flag ) * PicHeightInMapUnits
PictureHeightInMbs= ( 2 – frame_mbs_only_flag ) * PicHeightInMapUnits

**mb_adaptive_frame_field_flag** 指明本序列是否属于帧场自适应模式。mb_adaptive_frame_field_flag等于１时表明在本序列中的图像如果不是场模式就是帧场自适应模式，等于０时表示本序列中的图像如果不是场模式就是帧模式,以下列举了一个序列中可能出现的编码模式：
	a. 全部是帧，对应于 frame_mbs_only_flag =1 的情况。
	b. 帧和场共存。frame_mbs_only_flag =0, mb_adaptive_frame_field_flag =0
	c. 帧场自适应和场共存。frame_mbs_only_flag =0, mb_adaptive_frame_field_flag =1
值得注意的是，**帧和帧场自适应不能共存在一个序列中**。

**direct_8x8_inference_flag** 用于指明 B 片的直接和 skip 模式下运动矢量的预测方法。
frame_cropping_flag 用于指明解码器是否要将图像裁剪后输出，如果是的话，后面紧跟着的
四个句法元素分别指出左右、上下裁剪的宽度。

**frame_crop_left_offset,frame_crop_right_offset,frame_crop_bottom_offset,frame_crop_bottom_offset** 如上一句法元素所述。

vui_parameters_present_flag 指明 vui 子结构是否出现在码流中，vui 的码流结构在附录中指明，用以表征视频格式等额外信息。

### pps:

**pic_parameter_set_id** 用以指定本参数集的序号，该序号在各片的片头被引用。

**seq_parameter_set_id** 指明本图像参数集所引用的序列参数集的序号。

**entropy_coding_mode_flag** 指明熵编码的选择，本句法元素为０时，表示熵编码使用 CAVLC，本句法元素为１时表示熵编码使用 CABAC

**pic_order_present_flag** POC 的三种计算方法在片层还各需要用一些句法元素作为参数，本句法元素等于１时表示在片头会有句法元素指明这些参数；本句法元素等于０时，表示片头不会给出这些参数，这些参数使用默认值。

**num_slice_groups_minus1** 本句法元素加１后指明图像中片组的个数。Ｈ.264 中没有专门的句法元素用于指明是否使用片组模式，当本句法元素等于０（即只有一个片组），表示不使用片组模式，后面也不会跟有用于计算片组映射的句法元素。

**slice_group_map_type** 当 num_slice_group_minus1 大于０，既使用片组模式时，本句法元素出现在码流中，用以指明片组分割类型。
map_units 的定义：

- ​	 当 frame_mbs_only_flag 等于１时，map_units 指的就是宏块
- ​	 当 frame_mbs_only_falg 等于０时
  ​	 	帧场自适应模式时，map_units 指的是宏块对
   		场模式时，map_units 指的是宏块
  ​		 帧模式时，map_units 指的是与宏块对相类似的，上下两个连续宏块的组合体。

**run_length_minus1[i]** 用以指明当片组类型等于０时，每个片组连续的 map_units 个数。
**top_left[i],bottom_right[i]** 用以指明当片组类型等于２时，矩形区域的左上及右下位置。
**slice_group_change_direction_flag** 当片组类型等于３、４、５时，本句法元素与下一个句法元素
一起指明确切的片组分割方法。

**slice_group_change_rate_minus1** 用以指明变量 SliceGroupChangeRAte

**pic_size_in_map_units_minus1** 在片组类型等于６时，用以指明图像以 map_units 为单位的大小。

**slice_group_id[i]** 在片组类型等于６时，用以指明某个 map_units 属于哪个片组。

**num_ref_idx_l0_active_minus1** 加１后指明目前参考帧队列的长度，即有多少个参考帧（包括短期和长期）。值得注意的是，当目前解码图像是场模式下，参考帧队列的长度应该是本句法元素再乘以２，因为场模式下各帧必须被分解以场对形式存在。（这里所说的场模式包括图像的场及帧场自适应下的处于场模式的宏块对） 本句法元素的值有可能在片头被重载。读者可能还记得在序列参数集中有句法元素 num_ref_frames 也是跟参考帧队列有关，它们的区
别 是 num_ref_frames 指明参考帧队列的最大值，解码器用它的值来分配内存空间；

**num_ref_idx_l0_active_minus1** 指明在这个队列中当前实际的、已存在的参考帧数目，这从它的名字“active”中也可以看出来。这个句法元素是 H.264 中最重要的句法元素之一，在第章我们可以看到，编码器要通知解码器某个运动矢量所指向的是哪个参考图像时，并不是直接传送该图像的编号，而是传送该图像在参考帧队列中的序号。这个序号并不是在码流中传送的，而是编码器和解码器同步地、用相同的方法将参考图像放入队列，从而获得一个序号。这个队列在每解一个图像，甚至是每个片后都会动态地更新。维护参考帧队列是编解码器十分重要的工作，而本句法元素是维护参考帧队列的重要依据。参考帧队列的复杂的维护机制是 H.264 重要也是很有特色的组成部分

**num_ref_idx_l1_active_minus1** 与上一个句法元素的语义一致，只是本句法元素用于 list１，而上一句法元素用于 list0

**weighted_pred_flag** 用以指明是否允许Ｐ和ＳＰ片的加权预测，如果允许，在片头会出现用以计算加权预测的句法元素。

**weighted_bipred_flag** 用以指明是否允许 B 片的加权预测，本句法元素等于 0 时表示使用默认加权预测模式，等于 1 时表示使用显式加权预测模式，等于 2 时表示使用隐式加权预测模式。

**pic_init_qp_minus26** 加 26 后用以指明亮度分量的量化参数的初始值。在 H.264 中，量化参数分三个级别给出：图像参数集、片头、宏块。在图像参数集给出的是一个初始值。

**pic_init_qs_minus26** 与上一个句法元素语义一致，只是用于 SP 和 SI

**chroma_qp_index_offset** 色度分量的量化参数是根据亮度分量的量化参数计算出来的，本句法元素用以指明计算时用到的参数。

**deblocking_filter_control_present_flag** 编码器可以通过句法元素显式地控制去块滤波的强度，本句法元素指明是在片头是否会有句法元素传递这个控制信息。如果本句法元素等于 0，那些用于传递滤波强度的句法元素不会出现，解码器将独立地计算出滤波强度。

**constrained_intra_pred_flag** 在 P 和 B 片中，帧内编码的宏块的邻近宏块可能是采用的帧间编码。当本句法元素等于 1 时，表示帧内编码的宏块不能用帧间编码的宏块的像素作为自己的预测，即帧内编码的宏块只能用邻近帧内编码的宏块的像素作为自己的预测；而本句法元素等于 0 时，表示不存在这种限制。

**redundant_pic_cnt_present_flag**指明是否会出现 redundant_pic_cnt 句法元素。

## h265:

​	SPS + PPS +VPS

## av1:

### 	SPS

​		

--------------------------------------------------------
# 3.帧内预测模式：

## h264:

​    16X16块 有 DC + Planer + 水平 + 垂直 4 种
​    4X4块  有DC + 水平 + 垂直 + 6 种角度预测

## h265: 

​    DC + Planer + 33 种角度预测

## av1:

​    DC_PRED = 0,  
​	V_PRED,
​	H_PRED,
​	D45_PRED,
​	D135_PRED,
​	D113_PRED,
​	D157_PRED,
​	D203_PRED,
​	D67_PRED,
​	SMOOTH_PRED,
​	SMOOTH_V_PRED,
​	SMOOTH_H_PRED,
​	PAETH_PRED,
​	UV_CFL_PRED 

- 总结： dc + 3种 smoooth + PAETH_PRED + 
           角度预测(分别是 V + H +DXXX 一共八种分别前后补充三个间隔3度的模式，
           一共是 7 X8  = 56 种，这里把V ， H 本身也计入角度模式)
- ​    另外还有四种 interintra 模式
  ​        II_DC_PRED = 0,
  ​        II_V_PRED,
  ​        II_H_PRED,
  ​        II_SMOOTH_PRED,

    相关逻辑 看 predict_intra函数 
----------------------
# 4.熵编码

## h264 :

CAVLC/CABAC 自适应变长编码/自适应二进制算术编码
    RBSP = SODB + 对齐字节

## h265: 

CABAC 自适应二进制算术编码

## av1：

CDF 累计分布函数，**非二进制**算术编码

# 5.语法元素的解析方式

## h264 :

0阶指数哥伦布编码用于语法元素

若使用cavlc，则其只用于残差

cabac可用于语法元素或者残差

## h265: 

cabac用于残差和部分语法元素

vps sps pps 内的大部分语法元素都使用0阶指数哥伦布编码

## av1：

tile内所有语法元素/系数 都适用cdf进行编码、解析，之上的都是直接读


# 6.并行技术

## h264 :

​    图像/slice级别并行，2d-wave

## h265: 

​    wpp：entropy_coding_sync_enabled为1会在行头进行熵概率更新。则行与行之间的熵编码可并行。
​    gop/图像/slice/tile/ctb级别的并行

## av1 :

伪WPP 熵编码解码过程无法并行，其余步骤可并行
帧间并行

av1通用 并行编码方案：

![AV编码并行](videocodeciamges/AV编码并行.PNG)

# 7.变换系数扫描方式

## h264：

zig-zag

逆场扫描，用于场模式

## h265：

（没有zig-zag，只有类似的对角扫描，除了对角，还有水平，垂直共三种）

1.块被分成4X4进行扫描

2.块内的4X4之间与4X4内按照同样的方式进行扫描，都是对角或者都是垂直水平



## av1：

垂直 + 水平 + zig-zag + 对角

# 8.量化

 量化矩阵：使用量化矩阵，则块内的不同位置的实际量化值有区别，有一个映射值

## h264

h264中没有直接提出量化矩阵的概念，但是有一个 dct变换中的 ⊗E ，点乘一个常数矩阵的操作，和量化矩阵有些类似

量化参数的是编码 差值进入码流，解码的时候用预测值和差值相加的到实际的量化参数qp

  

## h265

hevc 存在qg的概念（量化组）qg内使用同样的量化参数，qg小于等于最大cb的大小，大于等于最小cb的大小



## av1

using_qmatrix 语法元素决定是否使用 量化矩阵











# 9.变换

## H264:

dct变换，Hadamard变换用于 **色度块** 或者  **帧内16X16的亮度块**** 

Hadamard 取2X2个4X4块中的每个dc系数组成 2X2 矩阵进行变换

## H265:

dct  dst  walsh-hadamard（由于划分TU，不像那样固定宏块大小，一个tu就一个dc系数，无法保证dc能够形成矩阵，所以 并未使用）

## AV1:

DCT  ADST   IDENTITY 这三种自由组合 两次一维变换，还包括flip版本的

identity 是简单的乘法

还有一个walsh-hadamard 用于LOSSLESS无损模式 只有4X4版本

# 10.MV预测方式

​       指 mv 本身的的预测值，加上mv的残差值，组成真正的mv

## 1.H264:

![h264mv预测](videocodeciamges/h264mv预测.PNG)

   定义A,B,C三个mv预测值，分别为左边，上边，右上的mv值

   取A,左边不止一个以左边最上方为准

   取B,上边不止一个以上边最左边为准

1） 传输分割不包括 16×8 和 8×16 时，MVp 为 A、B、C 分割 MV 的中值；
2） 16×8 分割，上面部分 MVp 由 B 预测，下面部分 MVp 由 A 预测；
3） 8×16 分割，左面部分 MVp 由 A 预测，右面部分 MVp 由 C 预测；
4） 跳跃宏块（skipped MB），同 1）。

##  2.H265:

![H265mv预测](videocodeciamges/H265mv预测.png)

 merge ： mv 由相邻的块的mv 直接得来，没有 mv 残差

 amvp： 有mv残差

 

## 3.AV1:



mv也采用 预测 + 残差的方式

mv预测过程 ：find_mv_stack 比较复杂

# 11.图像类型

## h264

 I/P/B  还有SP/SI SP:参考不同的图像构建相同的图像,主要用于流的切换

SP 分为主SP/辅SP 主SP仍然属于当前流，辅SP不属于当前流

P 帧与 SI 帧均可用于流间切换。当视频流的内容相同，编码参数不同采用 SP 帧；
而当视频流的内容相差很大时，则采用 SI 帧将更加有效

## h265

IRAP:随机介入点，只是一个点，不代表某个帧，从IRAP开始，后续图像可以独立解码，不必参考IRAP前面的图像

IRAP图像：是指 IRAP之后的第一张图像，其肯定是只包含帧内编码片，但是只包含帧内编码片的图像不一定是IRAP图像

IRAP前置图像：是指解码顺序在IRAP之后，但是显示顺序在IRAP之前的图像

IRAP后置图像： 是指显示顺序在IRAP之后的图像(其解码顺序必然在IRAP之后)

(IRAP)前置图像可分为以下两种，

- RADL图像：不依赖IRAP的图像
- RASL图像：依赖IRAP前的图像

IRAP可分为以下三种

- IDR ：后续码流完全不依赖其前方的码流，其前置图像也就必须是RADL

- CRA：允许前置图像是RASL,如果直接从CRA介入，则其RASL 是无法解码的

- BLA: 当CRA明确指定 其RASL不解码的时候 ，就是BLA

  ![IRAP](videocodeciamges/IRAP.PNG)

![hevc图像类型](videocodeciamges/hevc图像类型.PNG)

## av1：

​	KEY_FRAME:也就是 IDR

​	INTER_FRAME: P/B

​	INTRA_ONLY_FRAME: 普通I帧，后续的帧有可能参考 INTRA_ONLY_FRAME前面的帧

​	SWITCH_FRAM: 码流切换分辨率的时候使用 类似于264中的SP/SI





  decode picture buffer 中最多放8个帧 ，其中七个可以作为参考帧，分为7种类型，如下：

LAST_FRAME：POC小于当前帧的图像中最近的帧

LAST2_FRAME：POC小于当前帧的图像中第二接近的帧

LAST3_FRAME：POC小于当前帧的图像中第三接近的帧

GOLDEN_FRAME：POC小于当前帧的I帧或者GPB帧，类似于长期参考帧

BWDREF_FRAME：POC大于当前帧的图像中最接近当前帧的

ALTREF2_FRAME：POC大于当前帧的图像中第二接近当前帧的

ALTREF_FRAME：POC大于当前帧的图像中离当前帧最远的图像



ARF（Alternate Reference Frame）帧：也就是 ALTREF2_FRAME/ALTREF_FRAME

帧是一类特殊参考帧，它会被编码并在DFB中存储用于其他帧的帧间预测参考，但是不会在解码端显示。它对应的**showable_frame**语法元素值为0

ARF帧往往是对原始帧们进行时域滤波处理，以降低原始帧里的噪声而得到的帧，用它作为参考帧可以提高视频编码的性能




# 12.插值

## h264:

亮度：半像素使用一个六抽头滤波器。四分之一处由半像素出直接线性平均得来，对角处也采用对角平均

## h265:

亮度：半像素处使用一个八抽头滤波器，四分之一和四分之三处使用一个七抽头滤波器

​		   色度:以八分之一为单位，每个增加八分之一，都更换一种滤波器，但都是四抽头滤波器

​		 hevc中插值之后的值会对像素放大，之后会在加权预测过程中缩回去

## av1：

插值滤波器有    EIGHTTAP ,EIGHTTAP_SMOOTH ， EIGHTTAP_SHARP = 2, 三种滤波器，其中前两种为六抽头

​       第三种为八抽头

​      先进行水平方向上的插值，再进行垂直方向上的插值

​       当块的size小于等于4的时候，通过映射使用两种四抽头滤波器



# 13.加权预测

加权预测是对**非参考帧**已经预测出来的像素进行修正

## h264:

​	implict: 加权系数 由 当前到list0 list1参考图像的距离推出

​	explict: 加权系数保存在 sliceheader中

## h265:

​	默认加权预测：

​      explict：加权系数需要读取，分布在pps和sliceheader中

​      H265加权预测过程中还需要对像素进行缩小以抵消之前插值放大的部分

## av1：

 av1中加权预测逻辑看 predict_inter 最后面那一部分

​      COMPOUND_DISTANCE 需要使用加权系数

​    COMPOUND_AVERAGE 没有加权系数

   或者

​    COMPOUND_WEDGE = 0,

​    COMPOUND_DIFFWTD,

​    COMPOUND_AVERAGE,

这三种是mask模式，会根据mask值来生成加权系数

# 14.无损模式

## h264:

I_PCM

## h265:

PCM模式

## av1:

**CodedLossless** is a variable that is equal to 1 when all segments use lossless encoding. This indicates that the frame is
fully lossless at the coded resolution of FrameWidth by FrameHeight. In this case, the loop filter and CDEF filter are
disabled

**AllLossless** is a variable that is equal to 1 when CodedLossless is equal to 1 and FrameWidth is equal to
UpscaledWidth. This indicates that the frame is fully lossless at the upscaled resolution. In this case, the loop filter, CDEF
filter, and loop restoration are disabled.

# 15.参考帧管理

## h264

参考代码：h264_ref.c

### 滑动窗口

​	就是参考帧装在一个滑动窗口中，数量有限，需要一些机制来进行管理，下面mmco就是用来管理这个滑动窗口的

​	它直接指定当前帧和哪个帧有参考关系，写在slice header里面，这样可以灵活的决定要不要删除参考帧

### mmco

（**memory management control operatiopn**）用于管理参考帧

STR(短期参考帧)

LTR（长期参考帧）

1. MMCO_END : 解析mmco指令结束

2. MMCO_SHORTUNUSED : 把DPB中的一个STR标记为unused reference，此操作带有一个参数difference_of_pic_nums_minus1,由此参数可 以推算出需要设置为unused reference的pic_num.
3.  MMCO_LONGUNUSED : 把DPB中的一个LTR标记为unused reference,带有一个参数long_term_pic_num,此参数即为DPB中的LTR的索引编 号，long_term_pic_num的范围是0 - reference_num。
4. MMCO_SHORTTOLONG :把DPB中的一个STR标记为LTR并且给长期参考帧赋long_term_frame_idx，所以执行此命令需要找到需要标记为 LTR的STR，所以此命令有两个参数difference_of_pic_nums_minus1和long_term_frame_idx。通过第一个参数 找到参考帧列表中对应的STR，然后将其标记为LTR，并设置long_term_frame_idx。long_term_frame_idx和 long_term_pic_num不是一回事，两个值可以设置为一样。

5. MMCO_SET_MAX_LONG : 标记maximum long-term frame index,并且把大于此值的所有LTR标记为unused reference。其作用就是使当前部 分的长期参考帧置为“unused for reference”。如果max_long_term_frame_idx_plus1设置为0，则所有的长期 参考帧都无效。
6.  MMCO_RESET :  把DPB中所有的参考图像都设置为unused reference，并且把max_long_term_frame_idx设置为 "no long-term frame indices"（即相当于把max_long_term_frame_idx_plus1设置为0）。

7.  MMCO_LONG  : 把当前的picture设置为LTR，并且分配long-term frame index。



ff_h264_build_ref_list() ffmpeg h264解码器中构建参考列表的函数



### frame_num 

表示解码顺序

frame_num 在slice_header中

frame_num 参考帧才会增加，如果某个帧不是参考帧，其slice header中也有 frame_num 但其值与上一个参考帧一样，且值无意义

frame_num 是循环计数的，即当它到达MaxFrameNum 后又从0 重新开始新一轮的计数。解码器必须要有机制检测这种循环

非参考帧的frame_num在poc type为2或3时，用于poc值的计算

num_ref_idx_lx_active_minus1 (pps) 激活的参考队列长度

slice_header中（num_ref_idx_active_override_flag）确定是否覆盖pps中写的参考队列长度



### picture_order_count

表示显示顺序

在标识图像的播放顺序时，POC= `高位Msb`+ `低位Lsb`(按值相加，而非按位相加)

POC低位：pic_order_cnt_lsb = POC % MaxPicOrderCntLsb
　　　　		所占长度：log2_max_pic_order_cnt_lsb_minus4 + 4 个比特
　　　　		大小范围：[0 ， MaxPicOrderCntLsb – 1]
　　　　		注：MaxPicOrderCntLsb = 2^（log2_max_pic_order_cnt_lsb_minus4 + 4）
POC高位：pic_order_cnt_msb = POC - pic_order_cnt_lsb 【是MaxPicOrderCntLsb的整数倍】

poc 有三种类型：

pic_order_cnt_type = 0，把 POC 的低位（LSB）编进码流内
pic_order_cnt_type = 1，依赖 frame_num 求解 POC， 在 sps 和 slice_header 传递 bit ，POC 周期变化
pic_order_cnt_type = 2，显示顺序与解码顺序一致，不能出现 B 帧，限制最大 (直接从 frame_num 获取，POC 和 frmae_num 必须一致，不能有 B 帧，可以有非参考 P 帧)

**短期参考帧由上文中提到的 frame_num 标记，长期参考帧由另一个值 LongTermPicNum 标记**



在某一个时间点上，参考图像只能是这两种的其中一种（非短即长）。参考图像列表分为两个部分：短期参考部分，长期参考部分。**短期参考部分排在列表前头，长期排在后面**



-------------------------参考 https://blog.csdn.net/zhoutaopower/article/details/127342301

### 短期参考帧

对于一个短期参考帧，计算FrameNum和FrameNumWrap。当前帧的FrameNum和FrameNumWrap计算方法为：

首先设FrameNum的值为对应的短期参考帧的frame_num的值；
如果FrameNum的值大于当前帧slice_header中解析出的frame_num值，则FrameNumWrap的计算方式为：
FrameNumWrap = FrameNum - MaxFrameNum

否则，FrameNumWrap 的计算方式为：
FrameNumWrap = FrameNum

最后，对于每一个短期参考帧图像，计算 PicNum



### 长期参考帧

计算其LongTermFrameIdx的值





----------------------------

如果当前帧为帧编码，即field_pic_flag为0，则二者的值分别与FrameNumWrap和LongTermPicNum相等：

> **PicNum** = FrameNumWrap
>
> **LongTermPicNum** = LongTermFrameIdx
>
> 
>
> **PicNum**和 **LongTermPicNum**最终的在参考帧列表中的下标
>
> 

### p帧排序

一般来说，距离当前图像最近的参考图像会被当前图像用作最多的参考，距离越远则参考得越少，短期参考图像列表就是依据这种规律来进行排序的。

- 在P帧的参考帧列表 RefPicList0 中，短期参考帧排列在长期参考帧的前面，即短期参考帧的索引值均小于长期参考帧的索引。
- 排列短期参考帧：按照PicNum的顺序降序排列，即从PicNum最高的帧开始，一直到PicNum最低的帧为止。
- 排列长期参考帧：短期参考帧相反，是按照LongTermPicNum升序排列，即从LongTermPicNum最低的帧开始，一直到LongTermPicNum最高的帧为止。

举例如下，假设DPB最大容量为8，其中包含了5个短期参考帧和3个长期参考帧，那么P帧解码时的参考帧列表可用下图表示：


![h264 P帧排序](videocodeciamges/h264 P帧排序.png)

### b帧排序

初始化B帧参考帧列表的过程与P/SP稍有不同，主要体现在参考帧的排列顺序上

在两个参考帧列表RefPicList0和RefPicList1中，短期参考帧的顺序按照显示顺序，即POC进行排列。（P帧是按照编码顺序）

在排列短期参考帧时，会将当前帧的POC与DPB中参考帧的POC进行比较，然后根据结果进行以下操作：

- 对参考帧列表 refPicList0：
  如果DPB中短期参考帧的POC小于当前帧的POC，则短期参考帧按照POC的降序排列在参考帧列表refPicList0的前部，其余短期参考帧按照POC的升序紧随其后排列；
  DPB中的长期参考帧按照LongTermPicNum递增的顺序在短期参考帧之后排列；
- 对参考帧列表 refPicList1：
  如果DPB中短期参考帧的POC大于当前帧的POC，则短期参考帧按照POC的升序排列在参考帧列表refPicList1的前部，其余短期参考帧按照POC的降序紧随其后排列；
  DPB中的长期参考帧按照LongTermPicNum递增的顺序在短期参考帧之后排列；
  若refPicList1包含多于1个参考帧，且refPicList1与refPicList0等同时，refPicList1中前两个参考帧refPicList1[0]和refPicList1[1]将进行交换。


![H264 B帧排序](videocodeciamges/H264 B帧排序.png)

## h265

参考代码：hevc_ref.c

### 参考帧集技术（[RPS](https://so.csdn.net/so/search?q=RPS&spm=1001.2101.3001.7020)）

参考帧集技术，通过直接在每一帧开始的片头码流中传输DPB中各个帧的状态变化，将当前帧以及后续帧可能用到的参考帧在DPB中都进行描述，描述以POC作为一帧的身份标识。因此，它不需要依赖于前面帧的DPB状态，从而增强了抗差错性能

slice header中有语法元素 直接指定这些信息

### poc计算

每一个编码的帧都有一个POC，可以用变量PicOrderCntVal表示，取值范围为-2^31~2^31-1，所以POC值需要31比特表示，为了节省比特，码流中只传输POC的**低有效位**（LSB），而**高有效位**（MSB）可以由前面帧计算得到

PicOrderCntVal = PicOrderCntMsb + prevPicOrderCntLsb

#### prevTid0Pic

是指 时域层为0（TemporalId=0）且按解码顺序离当前图像最近的非RASL、RADL或SLNR（sub-layer non-reference picture）图像

#### prevPicOrderCntLsb计算

prevPicOrderCntLsb等于prevTid0Pic的 slice_pic_order_cnt_lsb



#### PicOrderCntMsb 计算

- 如果当前图像是IRAP图像，且NoRaslOutputFlag=1，则PicOrderCntMsb=0

- 否则

  ```c
  if( ( slice_pic_order_cnt_lsb < prevPicOrderCntLsb ) &&( ( prevPicOrderCntLsb − slice_pic_order_cnt_lsb ) >= ( MaxPicOrderCntLsb / 2 ) ) )
  	PicOrderCntMsb = prevPicOrderCntMsb + MaxPicOrderCntLsb
  else if( (slice_pic_order_cnt_lsb > prevPicOrderCntLsb ) &&( ( slice_pic_order_cnt_lsb − prevPicOrderCntLsb ) > ( MaxPicOrderCntLsb / 2 ) ) )
  	PicOrderCntMsb = prevPicOrderCntMsb − MaxPicOrderCntLsb
  else
  	PicOrderCntMsb = prevPicOrderCntMsb
  	
  ```

  其中prevPicOrderCntMsb 为prevTid0Pic的PicOrderCntMsb





### DPB



![hevc参考帧转换](videocodeciamges/hevc参考帧转换.png)

一幅图像解码后首先被初始化为短期参考图像。短期参考图像可以保持为短期参考图像或变为长期参考图像、非参考图像。长期参考图像可以保持为长期参考图像或变为非参考图像，但是不能变成短期参考图像。非参考图像不能变为参考图像

在 sps 中 有两个语法元素管控dpb

sps_max_num_reorder_pics：表示解码顺序在某图像之前，而显示顺序在该图像之后的图像的最大数量。

sps_max_latency_increase_plus1： 减1表示SpsMaxLatencyPictures，表示显示顺序在某图像之前，而解码顺序在该图像之后的图像的最大数量

## av1:

av1中没有poc

为了按正确顺序播放帧AV1采用show_frame / showable_frame / show_existing_frame机制来完成这一功能。这三个语法元素都写在frame_header中

show_frame：当前帧解码完后是否立刻输出。对于解码顺序在播放顺序前的帧该值为0。

showable_frame:这个标志只在show_frame=0时有意义，它是指当前帧是否可以显示。AV1有一个ARNR技术，它会对GPB帧进行一些时域滤波产生ARF帧，ARF帧只用作参考而不显示。

show_existing_frame：输出图像是否已经在DPB中。这个语法元素是为了显示那些延迟输出的图像。

frame_to_show_map_idx：当show_existing_frame=1时输出对应帧。

AV1通过语法元素refresh_frame_flags 来管理DFB状态。refresh_frame_flags 是一个8比特数据，每一位对应DFB中的一个位置，某位置1表示当前帧解码后替换DFB中的该帧



DFB具体更新过程为：

1、每帧图像编码前根据帧类型和其在GOP中的位置决定更新类型frame_update_type。

2、DPB中的帧根据和当前帧的位置关系等被分为三类：arf_stack、lst_stack、gld_stack。每类包含对应类型的参考帧。

1、当前帧编码完后检查DPB是否填满，若未填满则将当前帧加入DPB。若DPB已填满则根据每类帧的数量和类型选择最老的一帧替换掉。并根据该帧在DPB中的位置计算refresh_frame_flags 

参考列表构建：
	DFB构建完毕后当前帧需要使用DFB中的帧构建自己的参考列表，av1规定参考列表只能包含7帧。

- DPB中的帧被分为三类：arf_stack、lst_stack、gld_stack。

- 确定后向的参考帧,将arf_stack中的POC最大的帧作为ALTREF_FRAME（这一帧一般是当前GOP的GPB）；如果alt_stack中还有其他帧，则第0帧作为BWDREF_FRAME，第1帧作为ALTREF2_FRAME。若alf_stack中只有1帧则将其作为BWDREF_FRAME。

- 确定前向的参考帧,将lst_stack中的第0帧作为LAST_FRAME，第1帧作为LAST2_FRAME，如果lst_stack中还有帧则将第2帧作为LAST3_FRAME。

- 确定GOLDEN_FRAME,将golden_stack中的第0帧作为GOLDEN_FRAME，若golden_stack中还有帧且BWDREF_FRAME或者ALTREF_FRAME或者LAST3_FRAME未被指定，则用第1帧填充。

- 从后向前检查所有帧类型是否都已经被指定，如果还有一些帧还没有被指定，那么它分别在arf_ref、last_ref和golden_ref队列中寻找仍然没有被分配的帧，并将它指定为所需要的帧类型。

- 如果有些参考帧类型仍然没有被指定，那就将golden_ref中的第0帧指定为该类型的参考帧。

- 填充之后所有类型的参考帧都是可用的。编码器会记录下所有类型的参考帧在DPB中的位置，并把结果写入码流。这样解码器拿到DFB之后立刻就可以组合出参考帧队列。

- 这些参考帧类型有可能会有重复。在实际编码时需要进行去重，避免重复搜索
  

**参考列表如何在码流中传输**？构建完参考列表后需要在码流中写入每个参考帧对应在DFB中的位置，相关语法元素为ref_frame_idx

ref_frame_idx[i]

其中 i：0-6，

0表示LAST_FRAME,

1表示LAST2_FRAME，

2表示LAST3_FRAME，

3表示GOLDEN_FRAME，

4表示BWDREF_FRAME，

5表示ALTREF2_FRAME，

6表示ALTREF_FRAME。

那ref_frame_idx[LAST_FRAME]=5 就表示DPB 下标为5的位置上存在的帧(ref_frame_map[5])就是当前帧的LAST_FRAME。

ref_frame_idx的值有2种传输方式，当frame_refs_short_signaling=0的时候，所有的参考值都是显示传递的，也就是直接通过码流读取到的，当frame_refs_short_signaling=1的时候，只有last_frame_idx和gold_fame_idx是显示传递的，其他参考值则是通过计算得到的。


ARF（Alternate Reference Frame）帧是一类特殊参考帧，它会被编码并在DFB中存储用于其他帧的帧间预测参考，但是不会在解码端显示。它对应的showable_frame语法元素值为0。

ARF帧往往是对原始帧们进行时域滤波处理，以降低原始帧里的噪声而得到的帧，用它作为参考帧可以提高视频编码的性能

![AV1_ARF](videocodeciamges/AV1_ARF.png)



上图是含有ARF的AV1编码结构，这里的GOP大小4，灰色框表示的是需要显示的帧，ARF不需要显示用白色表示。

从上图可以看出，每一帧在显示之前需要完成解码，且ARF帧的解码顺序很靠前。这是因为通常ARF帧是时域滤波处理得到的，而时域滤波处理一般只对低layer的帧进行，这也意味着，在一个GOP里面并不是谁都可以成为ARF帧。

因为ARF帧解码后不显示，这会导致编码器送入的帧会比播放端的帧多，这时就需要overlay帧和ARF帧配合使用，这个Overlay它会以（相同帧号的）ARF作为参考帧进行预测编码得到压缩码流，当在解码端解码以后，可以显示它的画面，而且它自身不会被用来作参考帧

