 需要复习的算法题： 

1.寻找两个正序数组的中位数 
定义问题：假设有两个数组 nums1 和 nums2，长度分别为 m 和 n。我们需要找到这两个数组合并后的中位数。

核心思想 ：假设我们将两个数组分成左右两部分，使得：
左边部分的所有元素 ≤ 右边部分的所有元素。
左右两部分的元素个数尽可能相等（或相差 1，取决于总长度的奇偶性）。
如果满足上述条件，那么中位数就可以通过左边部分的最大值和右边部分的最小值计算得出。
具体实现 ：
假设 nums1 的长度为 m，nums2 的长度为 n，不失一般性，我们总是让 nums1 是较短的那个数组（即 m <= n）。如果 m > n，可以交换两个数组。
在 nums1 上进行二分查找，尝试找到一个分割点 i，使得 nums1[0:i] 和 nums2[0:j] 构成左边部分，nums1[i:] 和 nums2[j:] 构成右边部分。
分割点需要满足以下条件：
左边部分的元素个数等于右边部分的元素个数（或相差 1）。
左边部分的最大值 ≤ 右边部分的最小值。
边界条件 ：
如果分割点在数组的边界，则需要特殊处理，比如用 -∞ 或 +∞ 表示不存在的元素。
中位数计算 ：
如果总长度为奇数，中位数是左边部分的最大值。
如果总长度为偶数，中位数是左边部分的最大值和右边部分的最小值的平均值。

2.环形链表2

3.LRU

4.最小栈

5数组中的第K个最大元素

6.前 K 个高频元素

7.跳跃游戏(1)

8.单词拆分 

9.最长递增子序列  
辅助数组 tail 的定义：

使用一个辅助数组 tail，tail[i] 保存长度为 i+1 的递增子序列的最小末尾元素。tail 数组是递增的，但并不一定是最终的最长递增子序列。通过维护 tail，我们可以有效地跟踪最长递增子序列的长度。
遍历 nums 数组：

对于每个元素 num，使用二分查找来确定它应该插入到 tail 数组中的位置；如果 num 可以替换掉 tail 中的一个元素（即找到一个比 num 大的最小元素），则替换之；如果 num 大于 tail 中的所有元素，那么就将其添加到 tail 的末尾，并增加最长子序列的长度。
返回结果：tail 数组的长度即为最长递增子序列的长度。


10.分割等和子集 
转化为背包问题

11.最长有效括号
栈，左括号入栈，右括号则移除栈顶左括号，并更新最长有效括号的值，(当前位置到栈顶元素的距离差值)

12.最长公共子序列 
动态规划，考虑当前的 两个字符串的最后以一个字符是否相等即可，相等即为除去这最后一个字符串的值加一，不等为去除第一个或者第二个字符串的最后一个字符的值的最大值

13 .编辑距离
动态规划，分为三种，以其中一个字符串为基准，则为：删除一个，替换一个，增加一个（也可以是删除另一个字符串的最后一个，都一样）
然后实操也是考虑最后一个字符是否相等，
三种以dp表示： dp[i-1][j] dp[i][j-1] dp[i-1][j-1]
不等的时候，当前值为三种分别加1之后的最小值 
相等的时候，也是三种的最小值加一，但是dp[i-1][j-1]这种不用再加，因为相等不用改
14.多数元素

15.寻找重复数
